// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
ProjectionDirectional.ush: 
=============================================================================*/
#pragma once

#include "../DeferredShadingCommon.ush"
#include "../SceneTexturesCommon.ush"
#include "../LightShaderParameters.ush"
#include "../PathTracing/Utilities/PathTracingRandomSequence.ush"
#include "PageAccessCommon.ush"
#include "ProjectionCommon.ush"
#include "SMRTCommon.ush"


struct FSMRTClipmapRayState
{
	int ClipmapId;			// Pre-offset virtual shadow map ID of specific clipmap level
	int ClipmapIdAdjacent;	// Pre-offset virtual shadow map ID of specific clipmap level
	float3 RayStartShadowTexelsZ;	
	float3 RayStepShadowTexelsZ;
	float4 AdjacentTexelScaleBias;
	float2 AdjacentToBaseDepthScaleBias;
};

FSMRTClipmapRayState SMRTClipmapRayInitialize(
	int VirtualShadowMapId,
	float3 RayStart,
	float3 RayVector)
{
	const FVirtualShadowMapProjectionShaderData BaseProjectionData = GetVirtualShadowMapProjectionData(VirtualShadowMapId);

	// The page at RayStart has a high chance of being mapped since that is close to the receiver point
	// Thus we start our clipmap sampling around that page even as we walk through the depth space
	const float ClipmapLevelFloat = CalcClipmapLevelFloat(BaseProjectionData, RayStart);	
	const int ClipmapIndex = max(0, int(floor(ClipmapLevelFloat)) - BaseProjectionData.ClipmapLevel);
	const float ClipmapLevelFrac = frac(ClipmapLevelFloat);
	int ClipmapIndexAdjacent = ClipmapIndex + (ClipmapLevelFrac > 0.5f ? 1 : -1);
	ClipmapIndexAdjacent = clamp(ClipmapIndexAdjacent, 0, BaseProjectionData.ClipmapLevelCount - 1);

	const FVirtualShadowMapProjectionShaderData ProjectionData = GetVirtualShadowMapProjectionData(VirtualShadowMapId + ClipmapIndex);

	const float3 RayStartUV = mul(float4(RayStart + ProjectionData.ShadowPreViewTranslation, 1.0f), ProjectionData.TranslatedWorldToShadowUVMatrix).xyz;
	const float3 RayStepUV  = mul(float4(RayVector, 0.0f), ProjectionData.TranslatedWorldToShadowUVMatrix).xyz;

	const float LevelDims = float(CalcLevelDimsTexels(0));
	float3 RayStartShadowTexelsZ = float3(LevelDims, LevelDims, 1.0f) * RayStartUV.xyz;
	float3 RayStepShadowTexelsZ  = float3(LevelDims, LevelDims, 1.0f) * RayStepUV.xyz;

	// Work out scale/bias to convert to the adjacent UVs from the regular UVs
	const FVirtualShadowMapProjectionShaderData ProjectionDataAdjacent = GetVirtualShadowMapProjectionData(VirtualShadowMapId + ClipmapIndexAdjacent);

	// TranslatedWorldToShadowViewMatrix is identical for each of the cascades; only the pre-view translation changes
	float3 UVz         = mul(float4(ProjectionData.ShadowPreViewTranslation, 1.0f), ProjectionData.TranslatedWorldToShadowUVMatrix).xyz;
	float3 UVzAdjacent = mul(float4(ProjectionDataAdjacent.ShadowPreViewTranslation, 1.0f), ProjectionDataAdjacent.TranslatedWorldToShadowUVMatrix).xyz;

	float2 AdjacentTexelScale = (ProjectionDataAdjacent.ShadowViewToClipMatrix._11_22 / ProjectionData.ShadowViewToClipMatrix._11_22);
	float2 AdjacentTexelBias = LevelDims * (UVzAdjacent.xy - AdjacentTexelScale * UVz.xy);

	// Always rescale adjacent samples back to the same depth mapping as the regular clipmap level to ensure
	// precision is maintained and DepthHistory remains well defined.
	float AdjacentToBaseDepthScale = (ProjectionData.ShadowViewToClipMatrix._33 / ProjectionDataAdjacent.ShadowViewToClipMatrix._33);
	float AdjacentToBaseDepthBias = (UVz.z - AdjacentToBaseDepthScale * UVzAdjacent.z);
	
	FSMRTClipmapRayState Result;
	Result.ClipmapId = VirtualShadowMapId + ClipmapIndex;
	Result.ClipmapIdAdjacent = VirtualShadowMapId + ClipmapIndexAdjacent;
	Result.RayStartShadowTexelsZ = RayStartShadowTexelsZ;
	Result.RayStepShadowTexelsZ = RayStepShadowTexelsZ;
	Result.AdjacentTexelScaleBias = float4(AdjacentTexelScale, AdjacentTexelBias);
	Result.AdjacentToBaseDepthScaleBias = float2(AdjacentToBaseDepthScale, AdjacentToBaseDepthBias);
	return Result;

}

FSMRTSample SMRTFindSample(inout FSMRTClipmapRayState RayState, float SampleTime)
{
	FSMRTSample Sample = (FSMRTSample)0;
	Sample.bValid = false;
	
	const float3 SampleTexelsZ = RayState.RayStartShadowTexelsZ + RayState.RayStepShadowTexelsZ * SampleTime;

	uint2 PhysicalTexelAddress = uint2(0, 0);
	bool bValid = VirtualToPhysicalTexel(RayState.ClipmapId, 0, uint2(SampleTexelsZ.xy), PhysicalTexelAddress);

	float2 ToBaseDepthScaleBias = float2(1.0f, 0.0f);
	if (!bValid)
	{
		// Replace with adjacent level sample
		float2 AdjacentTexels = SampleTexelsZ.xy * RayState.AdjacentTexelScaleBias.xy + RayState.AdjacentTexelScaleBias.zw;
		bValid = VirtualToPhysicalTexel(RayState.ClipmapIdAdjacent, 0, uint2(AdjacentTexels), PhysicalTexelAddress);
		ToBaseDepthScaleBias = RayState.AdjacentToBaseDepthScaleBias;
	}

	if (bValid)
	{
		float SampleDepth = ToBaseDepthScaleBias.x * SampleVirtualShadowMapPhysicalDepth(PhysicalTexelAddress) + ToBaseDepthScaleBias.y;
		Sample.bValid = true;
		Sample.SampleDepth = SampleDepth;
		Sample.ReferenceDepth = SampleTexelsZ.z;
		Sample.CompareToleranceScale = RayState.RayStepShadowTexelsZ.z;
	}

	return Sample;
}

float SMRTComputeOccluderDistance(FSMRTClipmapRayState RayState, float SampleDepth)
{
	float4x4 ViewToClip = GetVirtualShadowMapProjectionData(RayState.ClipmapId).ShadowViewToClipMatrix;

	// No perspective projection, so simple difference gets us the distance
	float OccluderViewZ = (SampleDepth                      - ViewToClip._43) / ViewToClip._33;
	float ReceiverViewZ = (RayState.RayStartShadowTexelsZ.z - ViewToClip._43) / ViewToClip._33;
	float Result = ReceiverViewZ - OccluderViewZ;
	return max(VIRTUAL_SHADOW_MAP_MIN_OCCLUDER_DISTANCE, Result);
}

// Instantiate SMRTRayCast for FSMRTClipmapRayState
#define SMRT_TEMPLATE_RAY_STRUCT FSMRTClipmapRayState
#include "SMRTTemplate.ush"
#undef SMRT_TEMPLATE_RAY_STRUCT



FSMRTResult ShadowRayCastDirectional(
	int VirtualShadowMapId,
	float3 ViewPosition,
	float3 RayStart,
	float3 RayVector,	// RayEnd - RayStart
	int NumSteps,
	float StepOffset)
{	
	FSMRTClipmapRayState RayState = SMRTClipmapRayInitialize(VirtualShadowMapId, RayStart, RayVector);
	return SMRTRayCast(RayState, NumSteps, StepOffset);
}

float3 GetRandomDirectionalLightRayDir(FLightShaderParameters Light, float2 E)
{
	float3 RayDir = Light.Direction;
	{
		float2 DiskUV = UniformSampleDiskConcentric(E) * Light.SourceRadius;
		float3 N = RayDir;
		float3 dPdu = cross(N, (abs(N.x) > 1e-6f) ? float3(1, 0, 0) : float3(0, 1, 0));
		float3 dPdv = cross(dPdu, N);
		RayDir += dPdu * DiskUV.x + dPdv * DiskUV.y;
	}
	return normalize(RayDir);
}

float TraceDirectional(
	int VirtualShadowMapId,
	FLightShaderParameters Light,
	uint2 PixelPos,
	const float SceneDepth,
	float3 TranslatedWorldPosition,
	float RayStartOffset,
	uint RayCount,
	uint SamplesPerRay,
	float RayLengthScale,
	const half Noise)
{
	float3 WorldPosition = TranslatedWorldPosition - View.PreViewTranslation;
	float3 ViewPosition = mul(float4(TranslatedWorldPosition, 1.0f), View.TranslatedWorldToView).xyz;
	float DistanceFromViewOrigin = length(ViewPosition);

	// Compute max ray length based on view depth
	// This affects both how far we are willing to trace across the shadow map (for clipmaps this is related to view depth)
	// and the maximum size a penumbra can be.
	// Too high values will cause shadows to detach from their contact points (unless more samples are used).
	// Too low values will greatly restrict how large penumbras can be in screen space.
	float RayLength = RayLengthScale * DistanceFromViewOrigin;

	float StepOffset = Noise;

	uint RayMissCount = 0;
	uint i = 0;
	for ( ; i < RayCount; i++)
	{
		RandomSequence RandSequence;
		RandomSequence_Initialize(RandSequence, PixelPos, i, View.StateFrameIndexMod8, RayCount);
#if 1
		float2 E = RandomSequence_GenerateSample2D(RandSequence);
#else
		float2 E = float2(SobolIndex(SobolFrame, i << 3)) / 0x10000;
#endif

		float3 RayDir = GetRandomDirectionalLightRayDir(Light, E);
		// TODO, move the clipmap selection outside/before this offset
		float3 RayStart = WorldPosition + RayDir * RayStartOffset;

		FSMRTResult Result = ShadowRayCastDirectional(
			VirtualShadowMapId,
			ViewPosition,
			RayStart,
			RayDir * RayLength,
			SamplesPerRay,
			StepOffset);

		RayMissCount += Result.bValidHit ? 0 : 1;

#if SMRT_ADAPTIVE_RAY_COUNT && COMPILER_SUPPORTS_WAVE_VOTE
		if( i == 0 )
		{
			bool bHit = Result.bValidHit;
			if( bHit )
			{
				// TODO: Some simple heuristic for directional lights
				//bHit = Result.OccluderDistance * Light.SourceRadius * ( 0.25 * View.ViewSizeAndInvSize.y / ( SceneDepth * View.ClipToView[1][1] ) ) > max( DistToLight - Result.OccluderDistance, 0.001 );
			}

			// All lanes miss or hit something close enough to not be noisy.
			bool bAllLanesMiss = WaveActiveAllTrue( !bHit );
			if( bAllLanesMiss )
			{
				break;
			}
		}
		else if( i == 1 )
		{
			// After 2 iterations and all have hit, must be in umbra.
			bool bAllLanesHit = WaveActiveAllTrue( RayMissCount == 0 );
			if( bAllLanesHit )
			{
				break;
			}
		}
#endif
	}
	uint SampleCount = min(i + 1, RayCount);		// break vs regular for loop exit
	float RayMissFactor = float(RayMissCount) / float(SampleCount);
	return RayMissFactor;
}

// Generate a ray based on directional light source geometry (e.g, source radius)
bool GenerateRayDirectional(
	FLightShaderParameters Light,
	uint2 PixelPos,
	float3 TranslatedWorldPosition,
	float RayLengthScale,
	uint RayIndex,
	uint RayCount,
	inout float3 OutRayStart,
	inout float3 OutRayEnd)
{
	float3 WorldPosition = TranslatedWorldPosition - View.PreViewTranslation;
	float3 ViewPosition = mul(float4(TranslatedWorldPosition, 1.0f), View.TranslatedWorldToView).xyz;
	float DistanceFromViewOrigin = length(ViewPosition);

	// Compute max ray length based on view depth
	// This affects both how far we are willing to trace across the shadow map (for clipmaps this is related to view depth)
	// and the maximum size a penumbra can be.
	// Too high values will cause shadows to detach from their contact points (unless more samples are used).
	// Too low values will greatly restrict how large penumbras can be in screen space.
	float RayLength = RayLengthScale * DistanceFromViewOrigin;

	RandomSequence RandSequence;
	RandomSequence_Initialize(RandSequence, PixelPos, RayIndex, View.StateFrameIndexMod8, RayCount);
	float2 E = RandomSequence_GenerateSample2D(RandSequence);

	float3 RayDir = GetRandomDirectionalLightRayDir(Light, E);
	OutRayStart = WorldPosition;
	OutRayEnd = OutRayStart + RayDir * RayLength;
	return true;
}
