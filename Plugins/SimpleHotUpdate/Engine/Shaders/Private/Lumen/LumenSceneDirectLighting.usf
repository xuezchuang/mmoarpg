// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenSceneDirectLighting.usf
=============================================================================*/

#include "../Common.ush"
#include "LumenCardCommon.ush"
#define SUPPORT_CONTACT_SHADOWS 0
#define USE_IES_PROFILE 1
#include "../DeferredLightingCommon.ush"
#include "../VolumeLightingCommon.ush"
#define FILTER_DIRECTIONAL_LIGHT_SHADOWING 1
#include "../ForwardShadowingCommon.ush"
#include "/Engine/Generated/Material.ush"
#include "../LightFunctionCommon.ush"
#include "../GlobalDistanceFieldUtils.ush"
#include "../DistanceFieldLightingShared.ush"
#define DF_SHADOW_QUALITY 2
#include "../DistanceFieldShadowingShared.ush"

#if VIRTUAL_SHADOW_MAP
	#include "../VirtualShadowMaps/ProjectionCommon.ush"
#endif

#if USE_CLOUD_TRANSMITTANCE
	#include "../VolumetricCloudCommon.ush"
#endif

// Must match ELumenLightType in LumenSceneDirectLighting.cpp
#define LIGHT_TYPE_DIRECTIONAL 0
#define LIGHT_TYPE_POINT 1
#define LIGHT_TYPE_SPOT 2
#define LIGHT_TYPE_RECT 3

#ifndef HARDWARE_RAYTRACING_SHADOW_PASS_COMBINE
#define HARDWARE_RAYTRACING_SHADOW_PASS_COMBINE 0
#endif

/** Fade distance in x, disabled brightness in y, output for preview shadows mask in z. */
float3 LightFunctionParameters2;

float GetLightFunction(float3 WorldPosition) 
{
	float4 LightVector = mul(float4(WorldPosition, 1), LightFunctionWorldToLight);
	float3 LightFunction = GetLightFunctionColor(LightVector.xyz / LightVector.w, WorldPosition);

	float GreyScale = dot(LightFunction, .3333f).x;

	// Calculate radial view distance for stable fading
	float ViewDistance = length(View.WorldCameraOrigin - WorldPosition);

	float DistanceFadeAlpha = saturate((LightFunctionParameters2.x - ViewDistance) / (LightFunctionParameters2.x * .2f));
	// Fade to disabled based on LightFunctionFadeDistance
	GreyScale = lerp(LightFunctionParameters2.y, GreyScale, DistanceFadeAlpha);

	// Fade to disabled based on ShadowFadeFraction
	GreyScale = lerp(LightFunctionParameters2.y, GreyScale, LightFunctionParameters.y);
	return GreyScale;
}

Texture2D OpacityAtlas;
float MaxTraceDistance;
float StepFactor;
float SurfaceBias;
float TanLightSourceAngle;
float SlopeScaledSurfaceBias;
float SDFSurfaceBiasScale;
float VirtualShadowMapSurfaceBias;
uint ForceOffscreenShadowing;
int VirtualShadowMapId;
uint UseIESProfile;

#if HARDWARE_RAYTRACING_SHADOW_PASS_COMBINE
Texture2D<float> ShadowMaskAtlas;
#endif

float3 GetWorldPositionForShadowing(float3 WorldPosition, float3 L, float3 WorldNormal, float BiasScale)
{
	//@todo DynamicGI - derive from card texel size
	return WorldPosition + L * (SurfaceBias + SlopeScaledSurfaceBias * saturate(1 - dot(L, WorldNormal))) * BiasScale;
}

float TraceOffscreenShadows(float3 WorldPosition, float3 L, float3 ToLight, float3 WorldNormal)
{
	float ShadowFactor = 1.0f;

	// Offscreen shadowing, trace to light
	float TraceDistance = MaxTraceDistance;

	#if LIGHT_TYPE != LIGHT_TYPE_DIRECTIONAL
		TraceDistance = min(length(ToLight), MaxTraceDistance);
	#endif

	#define OFFSCREEN_SHADOWING_TRACE_GLOBAL_SDF 1

	#if OFFSCREEN_SHADOWING_TRACE_MESH_SDF && (LIGHT_TYPE == LIGHT_TYPE_DIRECTIONAL)
	{
		float3 WorldPositionForShadowing = GetWorldPositionForShadowing(WorldPosition, L, WorldNormal, 1.0f);

		uint NumIntersectingObjects = GetCulledNumObjects();
		uint CulledDataParameter = 0;
		GetShadowTileCulledData(WorldPositionForShadowing, CulledDataParameter, NumIntersectingObjects);

		float SubsurfaceDensity = 0;
		bool bUseSubsurfaceTransmission = false;

		ShadowFactor = ShadowRayTraceThroughCulledObjects(
			WorldPositionForShadowing,
			WorldPositionForShadowing + L * TraceDistance,
			TraceDistance,
			0, //@todo - TanLightSourceAngle - causes mismatch with CSM which doesn't support LightSourceAngle
			0,
			100,
			SubsurfaceDensity,
			CulledDataParameter,
			NumIntersectingObjects,
			true,
			true,
			bUseSubsurfaceTransmission,
			/*bExpandSurface*/ true);
	}
	#elif OFFSCREEN_SHADOWING_TRACE_GLOBAL_SDF
	{
		float3 WorldPositionForShadowing = GetWorldPositionForShadowing(WorldPosition, L, WorldNormal, SDFSurfaceBiasScale);

		FGlobalSDFTraceInput TraceInput = SetupGlobalSDFTraceInput(WorldPositionForShadowing, L, 0.0f, TraceDistance, 1.0f, 1.0f);
		FGlobalSDFTraceResult SDFResult = RayTraceGlobalDistanceField(TraceInput);

		//@todo - approximate cone trace from SDF for antialiasing
		ShadowFactor = GlobalSDFTraceResultIsHit(SDFResult) ? 0.0f : 1.0f;
	}
	#endif

	return ShadowFactor;
}

void LumenCardDirectLightingPS(
	FCardVSToPS CardInterpolants,
	out float4 OutColor : SV_Target0)
{
	float Opacity = Texture2DSampleLevel(OpacityAtlas, GlobalBilinearClampedSampler, CardInterpolants.AtlasCoord, 0).x;
	float3 Irradiance = 0;

	if (Opacity > 0)
	{
		FDeferredLightData LightData;
		{
			LightData.Position = DeferredLightUniforms.Position;
			LightData.InvRadius = DeferredLightUniforms.InvRadius;
			LightData.Color = DeferredLightUniforms.Color;
			LightData.FalloffExponent = DeferredLightUniforms.FalloffExponent;
			LightData.Direction = DeferredLightUniforms.Direction;  
			LightData.Tangent = DeferredLightUniforms.Tangent;
			LightData.SpotAngles = DeferredLightUniforms.SpotAngles;
			LightData.SourceRadius = DeferredLightUniforms.SourceRadius;
			LightData.SourceLength = DeferredLightUniforms.SourceLength;
			LightData.SoftSourceRadius = DeferredLightUniforms.SoftSourceRadius;
			LightData.SpecularScale = DeferredLightUniforms.SpecularScale;
			LightData.ContactShadowLength = abs(DeferredLightUniforms.ContactShadowLength);
			LightData.ContactShadowLengthInWS = DeferredLightUniforms.ContactShadowLength < 0.0f;
			LightData.DistanceFadeMAD = DeferredLightUniforms.DistanceFadeMAD;
			LightData.ShadowMapChannelMask = DeferredLightUniforms.ShadowMapChannelMask;
			LightData.ShadowedBits = DeferredLightUniforms.ShadowedBits;
			LightData.RectLightBarnCosAngle = DeferredLightUniforms.RectLightBarnCosAngle;
			LightData.RectLightBarnLength = DeferredLightUniforms.RectLightBarnLength;

			LightData.bInverseSquared = LightData.FalloffExponent == 0.0f;
			LightData.bRadialLight = LIGHT_TYPE != LIGHT_TYPE_DIRECTIONAL;
			LightData.bSpotLight = LIGHT_TYPE == LIGHT_TYPE_SPOT;
			LightData.bRectLight = LIGHT_TYPE == LIGHT_TYPE_RECT;
		}

		FLumenCardData LumenCardData = GetLumenCardData(CardInterpolants.CardId);

		float Depth = 1.0f - Texture2DSampleLevel(LumenCardScene.DepthAtlas, GlobalBilinearClampedSampler, CardInterpolants.AtlasCoord, 0).x;

		float3 LocalPosition;
		LocalPosition.xy = (CardInterpolants.AtlasCoord - LumenCardData.LocalPositionToAtlasUVBias) / LumenCardData.LocalPositionToAtlasUVScale;
		LocalPosition.z = -LumenCardData.LocalExtent.z + Depth * 2 * LumenCardData.LocalExtent.z;

		float3 WorldPosition = mul(LumenCardData.WorldToLocalRotation, LocalPosition) + LumenCardData.Origin;

		float3 LightColor = DeferredLightUniforms.Color;
		float3 L = LightData.Direction;
		float3 ToLight = L;
	
#if LIGHT_TYPE == LIGHT_TYPE_DIRECTIONAL
		float CombinedAttenuation = 1;
#else
		float LightMask = 1;
		if (LightData.bRadialLight)
		{
			LightMask = GetLocalLightAttenuation(WorldPosition, LightData, ToLight, L);
		}

		float Attenuation;

		if (LightData.bRectLight)
		{
			FRect Rect = GetRect(ToLight, LightData);
			FRectTexture RectTexture = InitRectTexture(DeferredLightUniforms.SourceTexture);
			Attenuation = IntegrateLight(Rect, RectTexture);
		}
		else
		{
			FCapsuleLight Capsule = GetCapsule(ToLight, LightData);
			Capsule.DistBiasSqr = 0;
			Attenuation = IntegrateLight(Capsule, LightData.bInverseSquared);
		}

		float CombinedAttenuation = Attenuation * LightMask;
#endif

		if (CombinedAttenuation > 0)
		{
			float3 WorldNormal = Texture2DSampleLevel(LumenCardScene.NormalAtlas, GlobalBilinearClampedSampler, CardInterpolants.AtlasCoord, 0).xyz * 2 - 1;

			if (dot(WorldNormal, L) > 0)
			{
				float ShadowFactor = 1.0f;

				#if SHADOWED_LIGHT 
				{
					#if HARDWARE_RAYTRACING_SHADOW_PASS_COMBINE
					{
						float2 AtlasTextureSize = LumenCardScene.AtlasSize;
						uint2 Pos2D = CardInterpolants.AtlasCoord * AtlasTextureSize.xy - float2(0.5, 0.5) / AtlasTextureSize.xy;
						ShadowFactor = ShadowMaskAtlas.Load(uint3(Pos2D, 0));
					}
					#else
					{
						bool bShadowFactorComplete = false;
						bool bVSMValid = false;

						#if VIRTUAL_SHADOW_MAP
						{
							// Bias only ray start to maximize chances of hitting an allocated page
							FVirtualShadowMapSampleResult VirtualShadowMapSample = SampleVirtualShadowMap(VirtualShadowMapId, WorldPosition, VirtualShadowMapSurfaceBias, WorldNormal);

							bVSMValid = VirtualShadowMapSample.bValid;
							bShadowFactorComplete = VirtualShadowMapSample.bValid && VirtualShadowMapSample.bOccluded;
							ShadowFactor = VirtualShadowMapSample.ShadowFactor;
						}
						#endif

						if (!bShadowFactorComplete)
						{
							float3 WorldPositionForShadowing = GetWorldPositionForShadowing(WorldPosition, L, WorldNormal, 1.0f);

							#if LIGHT_TYPE == LIGHT_TYPE_DIRECTIONAL
							{
								#if DYNAMICALLY_SHADOWED
									float SceneDepth = dot(WorldPositionForShadowing - View.WorldCameraOrigin, View.ViewForward);

									bool bShadowingFromValidUVArea = false;
									float NewShadowFactor = ComputeDirectionalLightDynamicShadowing(WorldPositionForShadowing, SceneDepth, bShadowingFromValidUVArea);

									float4 PostProjectionPosition = mul(float4(WorldPosition, 1.0), View.WorldToClip);
									// CSM's are culled so only query points inside the view are valid
									float2 ValidTexelSize = float2(length(ddx(WorldPosition)), length(ddy(WorldPosition))) * 2;
									if (bShadowingFromValidUVArea && all(PostProjectionPosition.xy - ValidTexelSize < PostProjectionPosition.w&& PostProjectionPosition.xy + ValidTexelSize > -PostProjectionPosition.w))
									{ 
										ShadowFactor *= NewShadowFactor;
										bShadowFactorComplete = VIRTUAL_SHADOW_MAP ? bVSMValid : true;
									}
								#endif
							}
							#else
							{
								bool bShadowingFromValidUVArea = false;
								float NewShadowFactor = ComputeVolumeShadowing(WorldPositionForShadowing, LightData.bRadialLight && !LightData.bSpotLight, LightData.bSpotLight, bShadowingFromValidUVArea);

								if (bShadowingFromValidUVArea) 
								{
									ShadowFactor *= NewShadowFactor;
									bShadowFactorComplete = VIRTUAL_SHADOW_MAP ? bVSMValid : true;
								}
							}
							#endif
						}

						bool bOffscreenShadowing = !bShadowFactorComplete;
						if (ForceOffscreenShadowing != 0)
						{
							ShadowFactor = 1.0;
							bOffscreenShadowing = true;
						}

						if (bOffscreenShadowing)
						{
							ShadowFactor *= TraceOffscreenShadows(WorldPosition, L, ToLight, WorldNormal);
						}
					}
					#endif // End hardware/software shadow selection		
				}
				#endif // End ShadowLight

				#if LIGHT_FUNCTION
					ShadowFactor *= GetLightFunction(WorldPosition);
				#endif

				#if USE_CLOUD_TRANSMITTANCE
				{
					float OutOpticalDepth = 0.0f;
					ShadowFactor *= lerp(1.0f, GetCloudVolumetricShadow(WorldPosition, CloudShadowmapWorldToLightClipMatrix, CloudShadowmapFarDepthKm, CloudShadowmapTexture, CloudShadowmapSampler, OutOpticalDepth), CloudShadowmapStrength);
				}
				#endif

				if (UseIESProfile > 0)
				{
					ShadowFactor *= ComputeLightProfileMultiplier(WorldPosition, DeferredLightUniforms.Position, -DeferredLightUniforms.Direction, DeferredLightUniforms.Tangent);
				}

				float NoL = saturate(dot(WorldNormal, L));
				Irradiance = LightColor * (CombinedAttenuation * NoL * ShadowFactor);
				//Irradiance = bShadowFactorValid ? float3(0, 1, 0) : float3(0.2f, 0.0f, 0.0f);
			}
		}
	}
		
	OutColor = float4(Irradiance, 0);
}