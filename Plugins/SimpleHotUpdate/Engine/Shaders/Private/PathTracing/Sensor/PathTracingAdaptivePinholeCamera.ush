// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================================
	PathTracingAdaptivePinholeCamera.ush: Reference path tracing camera functions
===============================================================================================*/

#pragma once

uint2 DimensionsAtLevel(uint Level)
{
	return uint2(AdaptiveSamplingData.VarianceDimensions.x >> Level, AdaptiveSamplingData.VarianceDimensions.y >> Level);
}

uint BufferOffsetAtPixel(uint2 Pixel, uint Level)
{
	uint Offset = 0;
	for (uint LevelIndex = 0; LevelIndex < Level; ++LevelIndex)
	{
		uint2 MipLevelDimensions = DimensionsAtLevel(LevelIndex);
		Offset += MipLevelDimensions.x * MipLevelDimensions.y;
	}

	uint2 MipLevelDimensions = DimensionsAtLevel(Level);
	Offset += Pixel.y * MipLevelDimensions.x + Pixel.x;
	return Offset;
}

uint Log2(uint Value)
{
	uint Result = 0;
	while (Value)
	{
		Result++;
		Value = Value >> 1;
	}
	return Result - 1;
}

bool DoAdaptiveSampling()
{
#if 1
	return false;
#else
	// TODO: remove this
	bool bVarianceMapExists = AdaptiveSamplingData.VarianceDimensions.x + AdaptiveSamplingData.VarianceDimensions.y > 0;
	bool bVarianceMapIsPrimed = AdaptiveSamplingData.Iteration >= AdaptiveSamplingData.MinimumSamplesPerPixel;
	bool bVarianceSumIsValid = false;
	if (bVarianceMapExists && bVarianceMapIsPrimed)
	{
		uint MipCount = Log2(AdaptiveSamplingData.VarianceDimensions.x);
		float VarianceSum = AdaptiveSamplingData.VarianceMipTree[BufferOffsetAtPixel(uint2(0, 0), MipCount)];
		float Epsilon = 0.0001;
		bVarianceSumIsValid = VarianceSum > Epsilon;
	}
	return bVarianceMapExists && bVarianceMapIsPrimed && bVarianceSumIsValid;
#endif
}

void AdaptivePinholeCamera_SampleEmitter(
	uint2 LaunchIndex,
	inout RandomSequence RandSequence,
	uint SourceEmitterId,
	uint SensorId,
	out RayDesc OutRay,
	out uint2 OutPixel,
	out float OutPdf
)
{
	// Fallback
	if (!DoAdaptiveSampling())
	{
		return PinholeCamera_SampleEmitter(LaunchIndex, RandSequence, SourceEmitterId, SensorId, OutRay, OutPixel, OutPdf);
	}
	OutPdf = 1.0;

	uint2 MipPixel = 0;
	uint MipCount = Log2(AdaptiveSamplingData.VarianceDimensions.x);

	float2 RandSample = RandomSequence_GenerateSample2D(RandSequence);
	uint StopLevel = 0;

	float OneMinusEps = 0.999999940395; // float just before 1.0
	for (uint Index = 0; Index < MipCount - StopLevel; ++Index)
	{
		uint MipIndex = MipCount - Index - 1;
		float Pdf00 = AdaptiveSamplingData.VarianceMipTree[BufferOffsetAtPixel(MipPixel, MipIndex)];
		float Pdf01 = AdaptiveSamplingData.VarianceMipTree[BufferOffsetAtPixel(MipPixel + uint2(0, 1), MipIndex)];
		float Pdf10 = AdaptiveSamplingData.VarianceMipTree[BufferOffsetAtPixel(MipPixel + uint2(1, 0), MipIndex)];
		float Pdf11 = AdaptiveSamplingData.VarianceMipTree[BufferOffsetAtPixel(MipPixel + uint2(1, 1), MipIndex)];

		// first decide between left / right:
		float PdfSum = (Pdf00 + Pdf01) + (Pdf10 + Pdf11);
		float ProbLeft = (Pdf00 + Pdf01) / PdfSum;

		if (RandSample.x < ProbLeft)
		{
			RandSample.x = min(RandSample.x / ProbLeft, OneMinusEps);
			// chose left - warp x and choose between the top / bottom pixels

			float ProbTop = Pdf00 / (Pdf00 + Pdf01);
			if (RandSample.y < ProbTop)
			{
				RandSample.y = min(RandSample.y / ProbTop, OneMinusEps);
				OutPdf *= 4 * Pdf00 / PdfSum;
			}
			else
			{
				RandSample.y = min((1.0 - RandSample.y) / (1.0 - ProbTop), OneMinusEps);
				OutPdf *= 4 * Pdf01 / PdfSum;
				MipPixel.y += 1;
			}
		}
		else
		{
			// chose right - warp x and choose between the top / bottom pixels
			RandSample.x = min((RandSample.x - ProbLeft) / (1.0 - ProbLeft), OneMinusEps);

			MipPixel.x += 1;

			float ProbTop = Pdf10 / (Pdf10 + Pdf11);
			if (RandSample.y < ProbTop)
			{
				RandSample.y = min(RandSample.y / ProbTop, OneMinusEps);
				OutPdf *= 4 * Pdf10 / PdfSum;
			}
			else
			{
				RandSample.y = min((1.0 - RandSample.y) / (1.0 - ProbTop), OneMinusEps);
				OutPdf *= 4 * Pdf11 / PdfSum;
				MipPixel.y += 1;
			}
		}

		MipPixel <<= 1;
	}

	MipPixel >>= 1;

	float2 MipPixelUV = (MipPixel + RandSample) / float2(DimensionsAtLevel(StopLevel));
	// Correct for ViewSize/BufferSize discrepancy
	MipPixelUV *= View.ViewSizeAndInvSize.xy * View.BufferSizeAndInvSize.zw;

	OutRay = CreatePrimaryRay(MipPixelUV);
	OutPixel = MipPixelUV * View.BufferSizeAndInvSize.xy;
}

void AdaptivePinholeCamera_PdfEmitter(
	RayDesc Ray,
	out float OutPdf
)
{
	if (!DoAdaptiveSampling())
	{
		return PinholeCamera_PdfEmitter(Ray, OutPdf);
	}

	OutPdf = 1.0;
}
