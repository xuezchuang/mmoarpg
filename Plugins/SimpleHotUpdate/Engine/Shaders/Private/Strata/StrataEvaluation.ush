// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "Strata.ush"

#include "../ParticipatingMediaCommon.ush"
#include "../MonteCarlo.ush"
#include "../SHCommon.ush"
#include "../ShadingModels.ush"
#include "../ThinFilmBSDF.ush"



// STRATA_TODO put in a common file
// Point lobe in off-specular peak direction
float3 StrataGetOffSpecularPeakReflectionDir(float3 Normal, float3 ReflectionVector, float Roughness)
{
	float a = Square(Roughness);
	return lerp(Normal, ReflectionVector, (1 - a) * (sqrt(1 - a) + a));
}

// When haziness is used, both lobes take equal part in the blending. Only roughness changes.
#define SPECULAR_HAZINESS_WEIGHT 0.5f



///////////////////////////////////////////////////////////////////////////////
// BSDF evaluate and sampling

struct FStrataBSDFContext
{
	FStrataBSDF BSDF;

	float3 N;
	float3 X;
	float3 Y;
	float3 V;
	float3 R;
	float3 H;

	float3 L;	// There to initialise the BxDFContext. Only used by StrataEvaluateBSDF, not by StrataImportanceSampleBSDF or StrataEvaluateForEnvLight

	BxDFContext Context;
	float SatNoL;
	float SatNoV;

	float3x3 TangentBasis;
	float3 TangentV;
	float3 TangentH;

	// Preprocessed roughness override used for specular BSDF evaluation when integration area light (using MRP integrator)
	float a2Override;
	float a2OverrideHazy;
};

void StrataGetBSDFRoughness(in FStrataBSDF BSDF, inout float R)
{
	R = 0;
	const uint BSDFType = BSDF_GETTYPE(BSDF);
	switch (BSDFType)
	{
	case STRATA_BSDF_TYPE_SLAB:
	{
		R = SLAB_ROUGHNESSX(BSDF);
		break;
	}
	case STRATA_BSDF_TYPE_SHEEN:
	{
		R = SHEEN_ROUGHNESS(BSDF);
		break;
	}
	case STRATA_BSDF_TYPE_HAIR:
	{
		R = HAIR_ROUGHNESS(BSDF);
		break;
	}
	case STRATA_BSDF_TYPE_SINGLELAYERWATER:
	{
		R = SLW_ROUGHNESS(BSDF);
		break;
	}
	}
}

FStrataBSDFContext StrataCreateBSDFContext(FStrataPixelHeader StrataPixelHeader, FStrataBSDF BSDF, float3 V, float3 L, bool bOverrideWithLocalFrame=false)
{
	FStrataBSDFContext BSDFContext = (FStrataBSDFContext)0;

	BSDFContext.BSDF = BSDF;

	BSDFContext.V = V;
	BSDFContext.L = L;

	float3x3 TangentBasis = StrataGetBSDFSharedBasis(StrataPixelHeader, BSDF);
	BSDFContext.X = TangentBasis[0]; 
	BSDFContext.Y = TangentBasis[1];
	BSDFContext.N = TangentBasis[2]; 
	if (bOverrideWithLocalFrame)
	{
		BSDFContext.X = float3(1,0,0);
		BSDFContext.Y = float3(0,1,0);
		BSDFContext.N = float3(0,0,1);
	}

	BSDFContext.R = 2 * dot(BSDFContext.V, BSDFContext.N) * BSDFContext.N - BSDFContext.V;
	BSDFContext.H = normalize(BSDFContext.V + BSDFContext.L);

	BSDFContext.Context = (BxDFContext)0;
	if (BSDF_GETANISOTROPY(BSDF) != 0)
	{
		Init(BSDFContext.Context, BSDFContext.N, BSDFContext.X, BSDFContext.Y, BSDFContext.V, BSDFContext.L);
	}
	else
	{
		Init(BSDFContext.Context, BSDFContext.N, BSDFContext.V, BSDFContext.L);
	}
	BSDFContext.TangentBasis = float3x3(BSDFContext.X, BSDFContext.Y, BSDFContext.N);

	BSDFContext.TangentV = mul(BSDFContext.TangentBasis, BSDFContext.V);
	BSDFContext.TangentH = mul(BSDFContext.TangentBasis, BSDFContext.H);

	BSDFContext.SatNoL = saturate(BSDFContext.Context.NoL);
	BSDFContext.SatNoV = saturate(BSDFContext.Context.NoV);

	return BSDFContext;
}

void StrataUpdateBSDFContext(inout FStrataBSDFContext BSDFContext, float3 NewL)
{
	// Update all the data related to L
	Init(BSDFContext.Context, BSDFContext.N, BSDFContext.V, NewL);
	BSDFContext.H = normalize(BSDFContext.V + BSDFContext.L);
	BSDFContext.TangentH = mul(BSDFContext.TangentBasis, BSDFContext.H);
}

struct FStrataEvaluateResult
{
	float3 EmissivePathValue;

	float3 DiffusePathValue;
	float3 SpecularPathValue;
	float3 SpecularHazePathValue;
	float3 TransmissionPathValue;

	// The following probabilities are part of the pdf to work correctly with a monter carlo based integrator and as expected are not applied on the xxxPathValue.
	// So PathProbability should be applied on PathValue in the rasteriser to recover the correct balance.
	float SpecularPathProbability;
	float SpecularHazePathProbability;

	float  DiffusePDF;
	float  SpecularPDF;
	float  SpecularHazePDF;
	float  TransmissionPDF;

	float3 Throughput;					// Throughput to the next layer
	bool   bSubsurface;					// True if we need to separate the subsurface light contribution for the screen space diffusion process.
	bool   bApplyProjectedSolidAngle;	// True if the Saturate(NoL) factor should be applied or not over the value of the BSDF
};

float StrataBSDFProjectedSolidAngleFactor(in FStrataBSDFContext BSDFContext)
{
	const uint BSDFType = BSDF_GETTYPE(BSDFContext.BSDF);
	return BSDFType == STRATA_BSDF_TYPE_HAIR ? 1.0f : BSDFContext.SatNoL;
}

FStrataEvaluateResult StrataEvaluateBSDF(FStrataBSDFContext BSDFContext, FShadowTerms ShadowTerms)
{
	FStrataEvaluateResult Sample = (FStrataEvaluateResult)0;

	const float OpaqueBSDFThroughput = 0.0f;

	const uint BSDFType = BSDF_GETTYPE(BSDFContext.BSDF);
	switch (BSDFType)
	{
		case STRATA_BSDF_TYPE_SLAB:
		{
			const float3 BaseColor = SLAB_BASECOLOR(BSDFContext.BSDF);
			const float  Metallic = SLAB_METALLIC(BSDFContext.BSDF);
			const float3 DiffuseColor = BaseColor - BaseColor * Metallic;
			const float SafeRoughness = MakeRoughnessSafe(SLAB_ROUGHNESSX(BSDFContext.BSDF));
			float a2 = Pow4(SafeRoughness);

			Sample.DiffusePathValue	= Diffuse_Chan(DiffuseColor, a2, BSDFContext.SatNoV, BSDFContext.SatNoL, BSDFContext.Context.VoH, BSDFContext.Context.NoH);
			Sample.DiffusePDF		= BSDFContext.SatNoV / PI;
			Sample.bSubsurface		= BSDF_GETHASSCATTERING(BSDFContext.BSDF) > 0;

			const float3 F0  = ComputeF0(SLAB_SPECULAR(BSDFContext.BSDF), BaseColor, Metallic);
			const float3 F90 = ComputeF90(F0, SLAB_EDGECOLOR(BSDFContext.BSDF), Metallic);

			const float SafeRoughnessX = MakeRoughnessSafe(SLAB_ROUGHNESSX(BSDFContext.BSDF));
			const float SafeRoughnessY = MakeRoughnessSafe(SLAB_ROUGHNESSY(BSDFContext.BSDF));

			const bool bHasAnisotropy = BSDF_GETANISOTROPY(BSDFContext.BSDF);
			const bool bHaziness = BSDF_GETHASHAZINESS(BSDFContext.BSDF);
			float D = 0;
			float Vis = 0;
			float PDF = 0;
			float HazeD = 0;
			float HazeVis = 0;
			float HazePDF = 0;
			if (bHasAnisotropy)
			{
				// Generalized microfacet specular
				float Alpha0 = Pow2(SafeRoughnessX);
				float Alpha1 = Pow2(SafeRoughnessY);
				D = D_GGXaniso(Alpha0, Alpha1, BSDFContext.Context.NoH, BSDFContext.Context.XoH, BSDFContext.Context.YoH);
				Vis = Vis_SmithJointAniso(Alpha0, Alpha1, BSDFContext.Context.NoV, BSDFContext.Context.NoL, BSDFContext.Context.XoV, BSDFContext.Context.XoL, BSDFContext.Context.YoV, BSDFContext.Context.YoL);
				PDF = VisibleGGXPDF_aniso(BSDFContext.TangentV, BSDFContext.TangentH, float2(Alpha0, Alpha1));

				if (bHaziness)
				{
					Alpha0 = Pow2(ComputeHazyLobeRoughness(SafeRoughnessX, SLAB_HAZINESS(BSDFContext.BSDF)));
					Alpha1 = Pow2(ComputeHazyLobeRoughness(SafeRoughnessY, SLAB_HAZINESS(BSDFContext.BSDF)));
					HazeD = D_GGXaniso(Alpha0, Alpha1, BSDFContext.Context.NoH, BSDFContext.Context.XoH, BSDFContext.Context.YoH);
					HazeVis = Vis_SmithJointAniso(Alpha0, Alpha1, BSDFContext.Context.NoV, BSDFContext.Context.NoL, BSDFContext.Context.XoV, BSDFContext.Context.XoL, BSDFContext.Context.YoV, BSDFContext.Context.YoL);
					HazePDF = VisibleGGXPDF_aniso(BSDFContext.TangentV, BSDFContext.TangentH, float2(Alpha0, Alpha1));
				}
			}
			else
			{
				// Special override for roughness for supporting area light integrator with Sphere/Tube/Disk light, which modifies/increase roughness.
				const float a2 = BSDFContext.a2Override > 0 ? BSDFContext.a2Override : Pow4(SafeRoughnessX);

				// Generalized microfacet specular
				D = D_GGX(a2, BSDFContext.Context.NoH);
				Vis = Vis_SmithJointApprox(a2, BSDFContext.Context.NoV, BSDFContext.SatNoL);
				PDF = VisibleGGXPDF(BSDFContext.TangentV, BSDFContext.TangentH, a2);

				if (bHaziness)
				{
					const float a2Haze = BSDFContext.a2OverrideHazy > 0 ? BSDFContext.a2OverrideHazy : Pow4(ComputeHazyLobeRoughness(SafeRoughnessX, SLAB_HAZINESS(BSDFContext.BSDF)));
					HazeD = D_GGX(a2Haze, BSDFContext.Context.NoH);
					HazeVis = Vis_SmithJointApprox(a2Haze, BSDFContext.Context.NoV, BSDFContext.SatNoL);
					HazePDF = VisibleGGXPDF(BSDFContext.TangentV, BSDFContext.TangentH, a2Haze);
				}
			}

			float3 F = 0;
			const bool bHasThinFilm = BSDF_GETHASTHINFILM(BSDFContext.BSDF);
			BRANCH
			if (!bHasThinFilm)
			{
				F = F_Schlick(F0, F90, BSDFContext.Context.VoH);
			}
			else
			{
				float ThinFilmIOR		= SLAB_THINFILM_IOR(BSDFContext.BSDF);
				float ThinFilmThickness = SLAB_THINFILM_THICKNESS(BSDFContext.BSDF);
				F = F_ThinFilm(BSDFContext.Context.NoV, BSDFContext.Context.NoL, BSDFContext.Context.VoH, F0, F90, ThinFilmIOR, ThinFilmThickness);
			}

			Sample.SpecularPathProbability	= bHaziness		? (1.0f - SPECULAR_HAZINESS_WEIGHT) : 1.0f;
			Sample.SpecularHazePathProbability= bHaziness	? SPECULAR_HAZINESS_WEIGHT			: 0.0f;

			Sample.SpecularPathValue		= D * Vis * F;
			Sample.SpecularPDF				= PDF * Sample.SpecularPathProbability;

			Sample.SpecularHazePathValue	= HazeD * HazeVis * F;
			Sample.SpecularHazePDF			= HazePDF * Sample.SpecularHazePathProbability;

			Sample.EmissivePathValue= BSDF_GETEMISSIVE(BSDFContext.BSDF);

			Sample.Throughput = OpaqueBSDFThroughput;
			break;
		}

		case STRATA_BSDF_TYPE_SHEEN:
		{
			const float3 F0  = SHEEN_BASECOLOR(BSDFContext.BSDF);
			const float SafeRoughness = MakeRoughnessSafe(SHEEN_ROUGHNESS(BSDFContext.BSDF));

			// Special override for roughness for supporting area light integrator with Sphere/Tube/Disk light, which modifies/increase roughness.
			const float a2 = BSDFContext.a2Override > 0 ? BSDFContext.a2Override : Pow4(SafeRoughness);

			// Generalized inverse microfacet specular
			float D   = D_InvGGX(a2, BSDFContext.Context.NoH);
			float Vis = Vis_Cloth(BSDFContext.Context.NoV, BSDFContext.SatNoL);
			float3 F  = F_Schlick(F0, BSDFContext.Context.VoH);

			Sample.DiffusePathValue	= D * Vis * F;
			Sample.DiffusePDF		= BSDFContext.SatNoV / PI; // Per "Production Friendly Microfacet Sheen BRDF", hemispherical sampling give good result as the roughness is usually high.
			Sample.Throughput		= (1.0f - F);
			break;
		}

		case STRATA_BSDF_TYPE_HAIR:
		{
			FGBufferData GBuffer	= (FGBufferData)0;
			GBuffer.BaseColor		= HAIR_BASECOLOR(BSDFContext.BSDF);
			GBuffer.Specular		= HAIR_SPECULAR(BSDFContext.BSDF);
			GBuffer.Roughness		= HAIR_ROUGHNESS(BSDFContext.BSDF);
			GBuffer.Metallic		= HAIR_SCATTER(BSDFContext.BSDF);
			GBuffer.CustomData.z	= HAIR_BACKLIT(BSDFContext.BSDF);
			GBuffer.ShadingModelID	= SHADINGMODELID_HAIR;
			GBuffer.WorldNormal		= BSDFContext.N;

			float BacklitEnabled = 1.0f;
			float Area = 0.0f;
			uint2 Random = uint2(0, 0);
			Sample.TransmissionPathValue= HairShading(GBuffer, BSDFContext.L, BSDFContext.V, BSDFContext.N, ShadowTerms.TransmissionShadow, ShadowTerms.HairTransmittance, BacklitEnabled, Area, Random);
			Sample.TransmissionPDF		= 1.0f / (4.0f * PI);		// STRATA_TODO this currently match the uniform sphere sampling from StrataImportanceSampleBSDF
			Sample.Throughput			= OpaqueBSDFThroughput; 
		}
		break;

		//case STRATA_BSDF_TYPE_VOLUMETRICFOGCLOUD:
		//case STRATA_BSDF_TYPE_UNLIT:
		//case STRATA_BSDF_TYPE_SINGLELAYERWATER:
		//Nothing to do in this case because these BSDF are evaluated in other specialised passes.
		//break;
	}

	return Sample;
}

FStrataEvaluateResult StrataEvaluateBSDF(FStrataBSDFContext BSDFContext)
{
	FShadowTerms Shadow = { 1, 1, 1, InitHairTransmittanceData() };
	return StrataEvaluateBSDF(BSDFContext, Shadow);
}

struct FStrataImportanceSampleResult
{
	float3 SpecularDirection;
	float  SpecularConeAngle;		// bad approximate of Cone angle as 1/PDF as done by Lumen STRATA_TODO update when Lumen is pluged in...

	float3 DiffuseDirection;
	float  DiffuseConeAngle;		// bad approximate of Cone angle as 1/PDF as done by Lumen STRATA_TODO update when Lumen is pluged in...

//	FStrataEvaluateResult Eval;
};

/**
 * Importance sample a Strata BSDF
 * BSDF: the strata BSDF to importance sample
 * E: two random numbers
 * CameraVector: vector from the camera to the considered direction (not V)
 */
FStrataImportanceSampleResult StrataImportanceSampleBSDF(FStrataPixelHeader StrataPixelHeader, FStrataBSDF BSDF, float2 E, float3 CameraVector)
{
	FStrataImportanceSampleResult Sample = (FStrataImportanceSampleResult)0;

	// Create a context from the information we have
	const float3 UnusedL = float3(0.0f, 0.0f, 1.0f);
	const float3 V = -CameraVector;
	FStrataBSDFContext BSDFContext = StrataCreateBSDFContext(StrataPixelHeader, BSDF, V, UnusedL);

	float PDF = 0.0f;
	const uint BSDFType = BSDF_GETTYPE(BSDF);
	switch (BSDFType)
	{
		case STRATA_BSDF_TYPE_SLAB:
		{
			const float3 BaseColor = SLAB_BASECOLOR(BSDFContext.BSDF);
			const float  Metallic = SLAB_METALLIC(BSDFContext.BSDF);

			// STRATA_TODO take into account roughness
			float4 ImportanceSample = CosineSampleHemisphere(E);
			Sample.DiffuseDirection = mul(ImportanceSample.xyz, BSDFContext.TangentBasis);
			PDF = ImportanceSample.w;
			Sample.DiffuseConeAngle = 1.0f / PDF;

			const float3 F0 = ComputeF0(SLAB_SPECULAR(BSDF), BaseColor, Metallic);
			// STRATA_TODO F82

			const float SafeRoughnessX = MakeRoughnessSafe(SLAB_ROUGHNESSX(BSDFContext.BSDF));
			const bool bHasAnisotropy = BSDF_GETANISOTROPY(BSDFContext.BSDF);
			float4 GGXSample = 0;
			if (bHasAnisotropy)
			{
				const float SafeRoughnessY = MakeRoughnessSafe(SLAB_ROUGHNESSY(BSDFContext.BSDF));
				GGXSample = ImportanceSampleVisibleGGX_aniso(UniformSampleDisk(E), float2(Pow2(SafeRoughnessX), Pow2(SafeRoughnessY)), BSDFContext.TangentV);
			}
			else
			{
				GGXSample = ImportanceSampleVisibleGGX(UniformSampleDisk(E), Pow4(SafeRoughnessX), BSDFContext.TangentV);
			}

			// STRATA_TODO: take into account Haziness

			float3 WorldH = mul(GGXSample.xyz, BSDFContext.TangentBasis);
			Sample.SpecularDirection = reflect(CameraVector, WorldH);
			PDF = GGXSample.w;
			Sample.SpecularConeAngle = 1.0f / PDF;
			break;
		}

		case STRATA_BSDF_TYPE_SHEEN:
		{
			// Per "Production Friendly Microfacet Sheen BRDF", uniform hemispherical sampling gives good result as the roughness is 
			// usually high and avoid issue at grazing angle
			float4 ImportanceSample = CosineSampleHemisphere(E);
			Sample.DiffuseDirection = mul(ImportanceSample.xyz, BSDFContext.TangentBasis);
			PDF = ImportanceSample.w;
			Sample.DiffuseConeAngle = 1.0f / PDF;
			break;
		}

		case STRATA_BSDF_TYPE_HAIR:
		{
			// STRATA_TODO do something better when we get there with Lumen, and evaluate the different researched solution (e.g. Importance Sampling for Physically-Based Hair Fiber Models)
			float4 ImportanceSample = CosineSampleHemisphere(E);
			Sample.DiffuseDirection = mul(ImportanceSample.xyz, BSDFContext.TangentBasis);
			PDF = ImportanceSample.w;
			Sample.DiffuseConeAngle = 1.0f / PDF;
			break;
		}

		//case STRATA_BSDF_TYPE_VOLUMETRICFOGCLOUD:
		//case STRATA_BSDF_TYPE_UNLIT:
		//case STRATA_BSDF_TYPE_SINGLELAYERWATER:
		//Nothing to do in this case because these BSDF are evaluated in other specialised passes.
		//break;
	}

	//StrataUpdateBSDFContext(BSDFContext, Sample.Direction);
	//Sample.Eval = StrataEvaluateBSDF(BSDFContext);
	//Sample.Eval.PDF = PDF;	// We override the pdf to make sure the compiler skips all pdf code from StrataEvaluateBSDF because GGXSample.w si the pdf already for instance.

	return Sample;
}

struct FStrataEnvLightResult
{
	float3 DiffuseColor;
	float3 DiffuseNormal;

	float3 SpecularDirection;
	float3 SpecularWeight;
	float  SpecularSafeRoughness;

	// Specular haze maintains the same off peak specular direction as the non hazy specular lobe
	float3 SpecularHazeWeight;
	float  SpecularHazeSafeRoughness;
	float  SSRReduction;

	bool   bSubsurface; // True if we need to separate the subsurface light contribution for the screen space diffusion process.
};

FStrataEnvLightResult StrataEvaluateForEnvLight(FStrataBSDFContext BSDFContext, bool bEnableSpecular)
{
	FStrataEnvLightResult StrataEnvLightResult = (FStrataEnvLightResult)0;

	const uint BSDFType = BSDF_GETTYPE(BSDFContext.BSDF);
	switch (BSDFType)
	{
		case STRATA_BSDF_TYPE_SLAB:
		{
			const float3 BaseColor = SLAB_BASECOLOR(BSDFContext.BSDF);
			const float  Metallic = SLAB_METALLIC(BSDFContext.BSDF);

			StrataEnvLightResult.DiffuseColor = BaseColor - BaseColor * Metallic;
			StrataEnvLightResult.DiffuseNormal = BSDFContext.N;
			StrataEnvLightResult.bSubsurface = BSDF_GETHASSCATTERING(BSDFContext.BSDF) > 0;

			BRANCH
			if (bEnableSpecular)
			{
				float3 F0 = ComputeF0(SLAB_SPECULAR(BSDFContext.BSDF), BaseColor, Metallic);
				const float3 F90 = ComputeF90(F0, SLAB_EDGECOLOR(BSDFContext.BSDF), Metallic);

				float3 FresnelWeight = 1;
				const bool bHasThinFilm = BSDF_GETHASTHINFILM(BSDFContext.BSDF);
				if (bHasThinFilm)
				{
					float ThinFilmIOR = SLAB_THINFILM_IOR(BSDFContext.BSDF);
					float ThinFilmThickness = SLAB_THINFILM_THICKNESS(BSDFContext.BSDF);
					FresnelWeight = F_ThinFilm(BSDFContext.Context.NoV, BSDFContext.Context.NoL, BSDFContext.Context.VoH, F0, F90, ThinFilmIOR, ThinFilmThickness);
					F0 = 1.f;
				}

				float SafeRoughnessX = MakeRoughnessSafe(SLAB_ROUGHNESSX(BSDFContext.BSDF));

				const bool bHasAnisotropy = BSDF_GETANISOTROPY(BSDFContext.BSDF);
				if (bHasAnisotropy)
				{
					const float SafeRoughnessY = MakeRoughnessSafe(SLAB_ROUGHNESSY(BSDFContext.BSDF));

					// Modified the BSDF normal (and roughness)
					float Anisotropy = 0;
					GetAnisotropicFactor(SafeRoughnessX, SafeRoughnessY, Anisotropy, SafeRoughnessX);
					ModifyGGXAnisotropicNormalRoughness(BSDFContext.X, Anisotropy, SafeRoughnessX, BSDFContext.N, BSDFContext.V);

					// Update context (only needs: NoL/SatNoL/R) with the new N
					BSDFContext.Context.NoL = dot(BSDFContext.N, BSDFContext.L);
					BSDFContext.SatNoL = saturate(BSDFContext.Context.NoL);
					BSDFContext.R = 2 * dot(BSDFContext.V, BSDFContext.N) * BSDFContext.N - BSDFContext.V;
				}

				float3 EvalEnvBRDF = FresnelWeight * EnvBRDFApprox(F0, F90, SafeRoughnessX, BSDFContext.SatNoV);

				StrataEnvLightResult.SpecularDirection = StrataGetOffSpecularPeakReflectionDir(BSDFContext.N, BSDFContext.R, SafeRoughnessX);
				StrataEnvLightResult.SpecularWeight = EvalEnvBRDF;
				StrataEnvLightResult.SpecularSafeRoughness = SafeRoughnessX;

				const bool bHasHaziness = BSDF_GETHASHAZINESS(BSDFContext.BSDF);
				if (bHasHaziness)
				{
					// Smoothly fade in haziness while fading out SSR to make sure we do not add energy and avoid popping.
					const float Haziness = SLAB_HAZINESS(BSDFContext.BSDF);
					const float HazinessFadeIn = saturate(Haziness / 0.1f);
					StrataEnvLightResult.SSRReduction = lerp(0.0f, SPECULAR_HAZINESS_WEIGHT, HazinessFadeIn);

					// Apply blend factor on the sharp specular contribution
					StrataEnvLightResult.SpecularWeight *= lerp(1.0f, (1.0f - SPECULAR_HAZINESS_WEIGHT), HazinessFadeIn);

					// Compute the second specular weight and roughness
					float SafeRoughnessHaze = ComputeHazyLobeRoughness(SafeRoughnessX, Haziness);
					StrataEnvLightResult.SpecularHazeWeight = lerp(0.0f, SPECULAR_HAZINESS_WEIGHT, HazinessFadeIn) * EnvBRDFApprox(F0, F90, SafeRoughnessHaze, BSDFContext.SatNoV);
					StrataEnvLightResult.SpecularHazeSafeRoughness = SafeRoughnessHaze;
				}
			}
			break;
		}

		case STRATA_BSDF_TYPE_SHEEN:
		{
			StrataEnvLightResult.DiffuseColor = SHEEN_BASECOLOR(BSDFContext.BSDF);;
			StrataEnvLightResult.DiffuseNormal = BSDFContext.N;
			break;
		}

		case STRATA_BSDF_TYPE_HAIR:
		{
			FGBufferData GBuffer	= (FGBufferData)0;
			GBuffer.BaseColor		= HAIR_BASECOLOR(BSDFContext.BSDF);
			GBuffer.Specular		= HAIR_SPECULAR(BSDFContext.BSDF);
			GBuffer.Roughness		= HAIR_ROUGHNESS(BSDFContext.BSDF);
			GBuffer.Metallic		= HAIR_SCATTER(BSDFContext.BSDF);
			GBuffer.CustomData.z	= HAIR_BACKLIT(BSDFContext.BSDF);
			GBuffer.ShadingModelID	= SHADINGMODELID_HAIR;
			GBuffer.WorldNormal		= BSDFContext.N;
			
			float BacklitEnabled = 0.0f;
			float Area = 0.2;
			uint2 Random = uint2(0, 0);
			float TransmissionShadow = 1.0f;
			FHairTransmittanceData TransmittanceData = InitHairTransmittanceData(true);

			const float3 N = BSDFContext.N;
			const float3 V = BSDFContext.V;
			float3 L = normalize(V - N * dot(V, N));
			StrataEnvLightResult.DiffuseNormal = L;

			StrataEnvLightResult.DiffuseColor = PI * HairShading(GBuffer, L, V, N, TransmissionShadow, TransmittanceData, BacklitEnabled, Area, Random);
			// No specular environment contribution as of today if not using the special HairStrand render path
			break;
		}

		//case STRATA_BSDF_TYPE_VOLUMETRICFOGCLOUD:
		//case STRATA_BSDF_TYPE_UNLIT:
		//case STRATA_BSDF_TYPE_SINGLELAYERWATER:
		//Nothing to do in this case because these BSDF are evaluated in other specialised passes.
		//break;
	}

	return StrataEnvLightResult;
}

FThreeBandSHVector StrataBSDFToSH(FStrataBSDFContext BSDFContext)
{
	FThreeBandSHVector SHVector;

	const uint BSDFType = BSDF_GETTYPE(BSDFContext.BSDF);
	if (BSDFType == STRATA_BSDF_TYPE_HAIR)
	{
		// Hack to avoid culling directions that hair will sample
		SHVector = (FThreeBandSHVector)0;
		SHVector.V0.x = 1.0f;
	}
	else
	{
		SHVector = CalcDiffuseTransferSH3(BSDFContext.N, 1.0f);
	}

	// STRATA_TODO adapt the SH to BSDFs
	return SHVector;
}


