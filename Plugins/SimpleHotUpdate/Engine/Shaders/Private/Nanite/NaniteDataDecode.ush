// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "../Common.ush"
#include "../BitPacking.ush"
#include "../SceneData.ush"
#include "PackedNaniteView.ush"

#define USE_CONSTRAINED_CLUSTERS				1														// must match define in NaniteBuilder.h
#define USE_UNCOMPRESSED_VERTEX_DATA			0														// must match define in NaniteBuilder.h

#define MAX_STREAMING_REQUESTS					( 128u * 1024u )										// must match define in NaniteResources.h
#define MAX_CLUSTER_TRIANGLES					128
#define MAX_CLUSTER_VERTICES					256

#define USE_STRIP_INDICES						1														// must match define in NaniteResources.h

#define CLUSTER_PAGE_GPU_SIZE_BITS				17														// must match define in NaniteResources.h
#define CLUSTER_PAGE_GPU_SIZE					( 1 << CLUSTER_PAGE_SIZE_BITS )							// must match define in NaniteResources.h
#define MAX_CLUSTERS_PER_PAGE_BITS				10														// must match define in NaniteResources.h
#define MAX_CLUSTERS_PER_PAGE_MASK				( ( 1 << MAX_CLUSTERS_PER_PAGE_BITS ) - 1 )				// must match define in NaniteResources.h
#define MAX_CLUSTERS_PER_PAGE					( 1 << MAX_CLUSTERS_PER_PAGE_BITS )						// must match define in NaniteResources.h
#define MAX_CLUSTERS_PER_GROUP_BITS				9														// must match define in NaniteResources.h
#define MAX_CLUSTERS_PER_GROUP_MASK				( ( 1 << MAX_CLUSTERS_PER_GROUP_BITS ) - 1 )			// must match define in NaniteResources.h
#define MAX_CLUSTERS_PER_GROUP					( ( 1 << MAX_CLUSTERS_PER_GROUP_BITS ) - 1 )			// must match define in NaniteResources.h
#define MAX_HIERACHY_CHILDREN_BITS				6														// must match define in NaniteResources.h
#define MAX_HIERACHY_CHILDREN					( 1 << MAX_HIERACHY_CHILDREN_BITS )						// must match define in NaniteResources.h
#define MAX_VIEWS_PER_CULL_RASTERIZE_PASS_BITS	12														// must match define in NaniteResources.h
#define MAX_VIEWS_PER_CULL_RASTERIZE_PASS_MASK	( ( 1 << MAX_VIEWS_PER_CULL_RASTERIZE_PASS_BITS ) - 1 )	// must match define in NaniteResources.h
#define MAX_VIEWS_PER_CULL_RASTERIZE_PASS		( 1 << MAX_VIEWS_PER_CULL_RASTERIZE_PASS_BITS )			// must match define in NaniteResources.h
#define MAX_GPU_PAGES_BITS						14														// must match define in NaniteResources.h
#define	MAX_GPU_PAGES_MASK						( ( 1 << MAX_GPU_PAGES_BITS ) - 1 )						// must match define in NaniteResources.h
#define	MAX_GPU_PAGES							( 1 << MAX_GPU_PAGES_BITS )								// must match define in NaniteResources.h
#define MAX_INSTANCES_BITS						24														// must match define in NaniteResources.h
#define MAX_NODES_PER_PRIMITIVE_BITS			16														// must match define in NaniteResources.h
#define MAX_RESOURCE_PAGES_BITS					20														// must match define in NaniteResources.h
#define MAX_RESOURCE_PAGES						(1 << MAX_FILE_PAGES_BITS)								// must match define in NaniteResources.h
#define MAX_GROUP_PARTS_BITS					3														// must match define in NaniteResources.h
#define MAX_GROUP_PARTS							(1 << MAX_GROUP_PARTS)									// must match define in NaniteResources.h

#define NUM_STREAMING_PRIORITY_CATEGORY_BITS	 2														// must match define in NaniteResources.h
#define STREAMING_PRIORITY_CATEGORY_MASK		((1 << NUM_STREAMING_PRIORITY_CATEGORY_BITS) - 1)		// must match define in NaniteResources.h

#define VIEW_FLAG_HZBTEST						0x1														// must match define in NaniteResources.h

#define MAX_STATE_BUCKET_ID						((1 << 14) - 1)											// must match FNaniteCommandInfo::MAX_STATE_BUCKET_ID

#define CLUSTER_FLAG_LEAF						0x1

#define MAX_TRANSCODE_GROUPS_PER_PAGE			128														// must match define in NaniteResources.h

#define NUM_PACKED_CLUSTER_FLOAT4S				8														// must match define in NaniteResources.h

#define MAX_POSITION_QUANTIZATION_BITS			21		// (21*3 = 63) < 64								// must match define in NaniteResources.h

#define NUM_CULLING_FLAG_BITS					3														// must match define in NaniteResources.h
#define CULLING_FLAG_TEST_LOD					0x1
#define CULLING_FLAG_USE_HW						0x2
#define CULLING_FLAG_FROM_DISOCCLUDED_INSTANCE	0x4

#define RENDER_FLAG_HAVE_PREV_DRAW_DATA			0x1
#define RENDER_FLAG_FORCE_HW_RASTER				0x2
#define RENDER_FLAG_PRIMITIVE_SHADER			0x4
#define RENDER_FLAG_OUTPUT_STREAMING_REQUESTS	0x8
#define RENDER_FLAG_REVERSE_CULLING				0x10

// Only available with the DEBUG_FLAGS permutation active.
#define DEBUG_FLAG_WRITE_STATS					0x1
#define DEBUG_FLAG_CULL_HZB_BOX					0x2
#define DEBUG_FLAG_CULL_HZB_SPHERE				0x4
#define DEBUG_FLAG_CULL_FRUSTUM_BOX				0x8
#define DEBUG_FLAG_CULL_FRUSTUM_SPHERE			0x10
#define DEBUG_FLAG_DRAW_ONLY_VSM_INVALIDATING	0x20

#ifndef DEBUG_FLAGS
#define DEBUG_FLAGS 0
#endif

uint GetHWClusterCounterIndex(uint InRenderFlags)
{
// Ensure rasterizer uses compile time constants.
#ifdef NANITE_PRIM_SHADER
	#if NANITE_PRIM_SHADER
		return 4;
	#else
		return 5;
	#endif
#else
	// Other passes use a uniform branch to minimize permutations.
	return (InRenderFlags & RENDER_FLAG_PRIMITIVE_SHADER) ? 4 : 5;
#endif
}

// Debug Visualization Modes (must match NaniteRender.cpp)
#define VISUALIZE_OVERVIEW							0u
#define VISUALIZE_TRIANGLES							(1u << 0u)
#define VISUALIZE_CLUSTERS							(1u << 1u)
#define VISUALIZE_PRIMITIVES						(1u << 2u)
#define VISUALIZE_INSTANCES							(1u << 3u)
#define VISUALIZE_GROUPS							(1u << 4u)
#define VISUALIZE_PAGES								(1u << 5u)
#define VISUALIZE_OVERDRAW							(1u << 6u)
#define VISUALIZE_RASTER_MODE						(1u << 7u)
#define VISUALIZE_SCENE_Z_MIN						(1u << 8u)
#define VISUALIZE_SCENE_Z_MAX						(1u << 9u)
#define VISUALIZE_SCENE_Z_DELTA						(1u << 10u)
#define VISUALIZE_MATERIAL_Z_MIN					(1u << 11u)
#define VISUALIZE_MATERIAL_Z_MAX					(1u << 12u)
#define VISUALIZE_MATERIAL_Z_DELTA					(1u << 13u)
#define VISUALIZE_MATERIAL_MODE						(1u << 14u)
#define VISUALIZE_MATERIAL_INDEX					(1u << 15u)
#define VISUALIZE_MATERIAL_DEPTH					(1u << 16u)
#define VISUALIZE_MATERIAL_COMPLEXITY				(1u << 17u)
#define VISUALIZE_HIT_PROXY_DEPTH					(1u << 18u)
#define VISUALIZE_NANITE_MASK						(1u << 19u)
#define VISUALIZE_LIGHTMAP_UVS						(1u << 20u)
#define VISUALIZE_LIGHTMAP_UV_INDEX					(1u << 21u)
#define VISUALIZE_LIGHTMAP_DATA_INDEX				(1u << 22u)
#define VISUALIZE_HIERARCHY_OFFSET					(1u << 23u)
#define VISUALIZE_POSITION_BITS						(1u << 24u)

struct FStats
{
	uint NumTris;
	uint NumVerts;
	uint NumViews;
	uint NumMainInstancesPreCull;
	uint NumMainInstancesPostCull;
	uint NumMainVisitedNodes;
	uint NumMainCandidateClusters;
	uint NumPostInstancesPreCull;
	uint NumPostInstancesPostCull;
	uint NumPostVisitedNodes;
	uint NumPostCandidateClusters;
	uint NumLargePageRectClusters;
	uint NumPrimaryViews;
	uint NumTotalViews;
};

struct FPersistentState
{
	uint	ClusterBatchReadOffset;	// Offset in batches
	uint	ClusterWriteOffset;		// Offset in individual clusters
	uint	NodeReadOffset;
	uint	NodeWriteOffset;
	int		NodeCount;				// Can temporarily be conservatively higher
};

struct FVisibleCluster
{
	uint	Flags;
	uint	ViewId;
	uint	InstanceId;
	uint	PageIndex;
	uint	ClusterIndex;
	uint2	vPage;
};

struct FCluster
{
	uint	PageBaseAddress;

	int3	QuantizedPosStart;
	uint	NumVerts;
	uint	PositionOffset;

	float3  MeshBoundsMin;
	uint	NumTris;
	uint	IndexOffset;

	float3	MeshBoundsDelta;
	uint	BitsPerIndex;
	uint	QuantizedPosShift;
	uint3	PosBits;

	float4	LODBounds;

	float3	BoxBoundsCenter;
	float	LODError;
	float	EdgeLength;

	float3	BoxBoundsExtent;
	uint	Flags;

	uint	AttributeOffset;
	uint	BitsPerAttribute;
	uint	DecodeInfoOffset;
	uint	NumUVs;
	uint	ColorMode;
	uint	UV_Prec;

	uint	ColorMin;
	uint	ColorBits;
	uint	GroupIndex;		// Debug only

	// Material Slow path
	uint	MaterialTableOffset;
	uint	MaterialTableLength;

	// Material Fast path
	uint	Material0Length;
	uint	Material0Index;
	uint 	Material1Length;
	uint	Material1Index;
	uint	Material2Index;
};

struct FHierarchyNodeSlice
{
	float4	LODBounds;
	float3	BoxBoundsCenter;
	float3	BoxBoundsExtent;
	float	MinLODError;
	float	MaxParentLODError;
	uint	ChildStartReference;	// Can be node (index) or cluster (page:cluster)
	uint	NumChildren;
	uint	StartPageIndex;
	uint	NumPages;
	bool	bEnabled;
	bool	bLoaded;
	bool	bLeaf;
};

struct FInstanceDynamicData
{
	float4x4	LocalToTranslatedWorld;
	float4x4	LocalToClip;
	float4x4	ClipToLocal;
	float4x4 	PrevLocalToClip;
	float3		ViewPosScaledLocal;
	float3		ViewForwardScaledLocal;
	bool		bHasMoved;
};

struct FNaniteView
{
	float4x4	TranslatedWorldToView;
	float4x4	TranslatedWorldToClip;
	float4x4	ViewToClip;
	float4x4	ClipToWorld;
	
	float4x4	PrevTranslatedWorldToView;
	float4x4	PrevTranslatedWorldToClip;
	float4x4	PrevViewToClip;
	float4x4	PrevClipToWorld;

	int4		ViewRect;
	float4		ViewSizeAndInvSize;
	float4		ClipSpaceScaleOffset;
	float3		PreViewTranslation;
	float3		PrevPreViewTranslation;
	float3		WorldCameraOrigin;
	float3		ViewForward;
	float		NearPlane;
	float		LODScale;
	float		LODScaleHW;
	float		MinBoundsRadiusSq;
	uint		StreamingPriorityCategory;
    uint		Flags;
	int			TargetLayerIndex;
	int			TargetMipLevel;
	int			TargetNumMipLevels;
	int			TargetPrevLayerIndex;
	int4		HZBTestViewRect;
};

struct FInstanceDraw
{
	uint InstanceId;
	uint ViewId;
};

#if NANITE_USE_UNIFORM_BUFFER
	#define SOAStrides 				Nanite.SOAStrides
	#define MaxNodes				Nanite.MaxNodes
	#define MaxVisibleClusters		Nanite.MaxVisibleClusters
	#define RenderFlags				Nanite.RenderFlags
	#define DebugFlags				Nanite.DebugFlags
	#define ClusterPageData			Nanite.ClusterPageData
	#define ClusterPageHeaders		Nanite.ClusterPageHeaders
	#define VisibleClustersSWHW		Nanite.VisibleClustersSWHW
#else
	uint4 							SOAStrides;
	uint							MaxNodes;
	uint							MaxVisibleClusters;
	uint							RenderFlags;
	uint							DebugFlags;
	ByteAddressBuffer 				ClusterPageData;
	ByteAddressBuffer 				ClusterPageHeaders;
	ByteAddressBuffer				VisibleClustersSWHW;
#endif

RWByteAddressBuffer					OutInstanceDynamicData;


uint4 PackVisibleCluster(uint ClusterIdx, FVisibleCluster VisibleCluster, bool bHasPageData)
{
	uint4 RawData = 0;
	uint BitPos = 1;	// Start at 1 to make sure RawData.x is always != 0xFFFFFFFFu
	WriteBits(RawData, BitPos, VisibleCluster.Flags, NUM_CULLING_FLAG_BITS);
	WriteBits(RawData, BitPos, VisibleCluster.ViewId, MAX_VIEWS_PER_CULL_RASTERIZE_PASS_BITS);
	WriteBits(RawData, BitPos, VisibleCluster.InstanceId, MAX_INSTANCES_BITS);
	WriteBits(RawData, BitPos, VisibleCluster.PageIndex, MAX_GPU_PAGES_BITS);
	WriteBits(RawData, BitPos, VisibleCluster.ClusterIndex, MAX_CLUSTERS_PER_PAGE_BITS);
	if (bHasPageData)
	{
		WriteBits(RawData, BitPos, VisibleCluster.vPage.x, 16);
		WriteBits(RawData, BitPos, VisibleCluster.vPage.y, 16);
	}
	return RawData;
}

FVisibleCluster UnpackVisibleCluster(uint4 RawData, bool bHasPageData = false)
{
	uint BitPos = 1;	// Start at 1 to make sure RawData.x is always != 0xFFFFFFFFu
	FVisibleCluster VisibleCluster;
	VisibleCluster.Flags		= ReadBits( RawData, BitPos, NUM_CULLING_FLAG_BITS );
	VisibleCluster.ViewId		= ReadBits( RawData, BitPos, MAX_VIEWS_PER_CULL_RASTERIZE_PASS_BITS );
	VisibleCluster.InstanceId	= ReadBits( RawData, BitPos, MAX_INSTANCES_BITS );
	VisibleCluster.PageIndex	= ReadBits( RawData, BitPos, MAX_GPU_PAGES_BITS );
	VisibleCluster.ClusterIndex	= ReadBits( RawData, BitPos, MAX_CLUSTERS_PER_PAGE_BITS );
	if( bHasPageData )
	{
		VisibleCluster.vPage.x	= ReadBits( RawData, BitPos, 16 );
		VisibleCluster.vPage.y	= ReadBits( RawData, BitPos, 16 );
	}
	else
	{
		VisibleCluster.vPage = 0;
	}

	return VisibleCluster;
}

FVisibleCluster GetVisibleCluster( ByteAddressBuffer VisibleClusters, uint ClusterIdx, bool bHasPageData = false )
{
	uint4 RawData;
	if( bHasPageData )
		RawData = uint4( VisibleClusters.Load3( ClusterIdx * 12 ), 0 );
	else
		RawData = uint4( VisibleClusters.Load2( ClusterIdx * 8 ), 0, 0 );

	return UnpackVisibleCluster(RawData, bHasPageData);
}

FVisibleCluster GetVisibleCluster( uint ClusterIdx, bool bHasPageData )
{
	return GetVisibleCluster( VisibleClustersSWHW, ClusterIdx, bHasPageData );
}

FVisibleCluster GetVisibleCluster( uint ClusterIndex )
{
	FVisibleCluster VisibleCluster;

	bool bImposter = ClusterIndex >= (1 << 24);
	if( bImposter )
	{
		// Couldn't have been stored so signals this is an imposter
		VisibleCluster.Flags = 1 << NUM_CULLING_FLAG_BITS;
		VisibleCluster.ViewId = 0;	// TODO
		VisibleCluster.InstanceId = BitFieldExtractU32( ClusterIndex, MAX_INSTANCES_BITS - 1, 1 );
		VisibleCluster.PageIndex = 0;
		VisibleCluster.ClusterIndex = ClusterIndex & 1;
	}
	else
	{
		VisibleCluster = GetVisibleCluster( ClusterIndex, false );
	}

	return VisibleCluster;
}

FInstanceSceneData GetInstanceData( inout FVisibleCluster VisibleCluster )
{
	FInstanceSceneData InstanceData = GetInstanceData( VisibleCluster.InstanceId, SOAStrides.x );

	// Couldn't have been stored so signals this is an imposter
	if( VisibleCluster.Flags == (1 << NUM_CULLING_FLAG_BITS) )
	{
		const uint MaxStreamingPages = 1 << 12;
		VisibleCluster.PageIndex = MaxStreamingPages + (InstanceData.NaniteRuntimeResourceID & MAX_GPU_PAGES_MASK);
	}

	return InstanceData;
}

FInstanceDynamicData CalculateInstanceDynamicData( FNaniteView NaniteView, FInstanceSceneData InstanceData )
{
	float4x4 LocalToWorld = InstanceData.LocalToWorld;
	float4x4 WorldToLocal = InstanceData.WorldToLocal;

	float4x4 LocalToTranslatedWorld = LocalToWorld;
	LocalToTranslatedWorld[3].xyz += NaniteView.PreViewTranslation.xyz;

	float4x4 PrevLocalToTranslatedWorld = InstanceData.PrevLocalToWorld;
	PrevLocalToTranslatedWorld[3].xyz += NaniteView.PrevPreViewTranslation.xyz;

	FInstanceDynamicData DynamicData;
	DynamicData.LocalToTranslatedWorld = LocalToTranslatedWorld;
	DynamicData.LocalToClip = mul( LocalToTranslatedWorld, NaniteView.TranslatedWorldToClip );
	DynamicData.ClipToLocal = mul( NaniteView.ClipToWorld, WorldToLocal );

	DynamicData.PrevLocalToClip	= mul( PrevLocalToTranslatedWorld, NaniteView.PrevTranslatedWorldToClip );

	DynamicData.ViewPosScaledLocal = mul( float4( NaniteView.WorldCameraOrigin.xyz, 1 ), WorldToLocal ).xyz * InstanceData.NonUniformScale.xyz;
	DynamicData.ViewForwardScaledLocal = mul( float4( NaniteView.ViewForward.xyz, 0 ), WorldToLocal ).xyz * InstanceData.NonUniformScale.xyz;

	DynamicData.bHasMoved = GetGPUSceneFrameNumber() == InstanceData.LastUpdateSceneFrameNumber;

	return DynamicData;
}

FInstanceSceneData GetInstanceData( uint InstanceId )
{
	return GetInstanceData( InstanceId, SOAStrides.x );
}

FCluster GetCluster(ByteAddressBuffer InputBuffer, uint SrcBaseOffset, uint ClusterIndex, uint NumPageClusters)
{
	uint ClusterSOAStride = ( NumPageClusters << 4 );

	uint ClusterBaseAddress = SrcBaseOffset + ( ClusterIndex << 4 );
	
	uint4 ClusterData[8];
	ClusterData[0] = InputBuffer.Load4( ClusterBaseAddress + 0 * ClusterSOAStride );
	ClusterData[1] = InputBuffer.Load4( ClusterBaseAddress + 1 * ClusterSOAStride );
	ClusterData[2] = InputBuffer.Load4( ClusterBaseAddress + 2 * ClusterSOAStride );
	ClusterData[3] = InputBuffer.Load4( ClusterBaseAddress + 3 * ClusterSOAStride );
	ClusterData[4] = InputBuffer.Load4( ClusterBaseAddress + 4 * ClusterSOAStride );
	ClusterData[5] = InputBuffer.Load4( ClusterBaseAddress + 5 * ClusterSOAStride );
	ClusterData[6] = InputBuffer.Load4( ClusterBaseAddress + 6 * ClusterSOAStride );
	ClusterData[7] = InputBuffer.Load4( ClusterBaseAddress + 7 * ClusterSOAStride );

	FCluster Cluster;
	Cluster.PageBaseAddress		= 0;

	Cluster.QuantizedPosStart	= ClusterData[0].xyz;
	Cluster.NumVerts			= BitFieldExtractU32(ClusterData[0].w, 9, 0);
	Cluster.PositionOffset		= BitFieldExtractU32(ClusterData[0].w, 23, 9);

	Cluster.MeshBoundsMin		= asfloat( ClusterData[1].xyz );
	Cluster.NumTris				= BitFieldExtractU32(ClusterData[1].w, 8, 0);
	Cluster.IndexOffset			= BitFieldExtractU32(ClusterData[1].w, 24, 8);

	Cluster.MeshBoundsDelta		= asfloat( ClusterData[2].xyz );
	Cluster.BitsPerIndex		= BitFieldExtractU32(ClusterData[2].w, 4, 0);
	Cluster.QuantizedPosShift	= BitFieldExtractU32(ClusterData[2].w, 6, 4);

	Cluster.PosBits.x			= BitFieldExtractU32(ClusterData[2].w, 5, 10);
	Cluster.PosBits.y			= BitFieldExtractU32(ClusterData[2].w, 5, 15);
	Cluster.PosBits.z			= BitFieldExtractU32(ClusterData[2].w, 5, 20);

	Cluster.LODBounds			= asfloat(ClusterData[3]);

	Cluster.BoxBoundsCenter		= asfloat(ClusterData[4].xyz);
	Cluster.LODError			= f16tof32(ClusterData[4].w);
	Cluster.EdgeLength			= f16tof32(ClusterData[4].w >> 16);

	Cluster.BoxBoundsExtent		= asfloat(ClusterData[5].xyz);
	Cluster.Flags				= ClusterData[5].w;

	Cluster.AttributeOffset		= BitFieldExtractU32(ClusterData[6].x, 22,  0);
	Cluster.BitsPerAttribute	= BitFieldExtractU32(ClusterData[6].x, 10, 22);
	Cluster.DecodeInfoOffset	= BitFieldExtractU32(ClusterData[6].y, 22,  0);
	Cluster.NumUVs				= BitFieldExtractU32(ClusterData[6].y,  3, 22);
	Cluster.ColorMode			= BitFieldExtractU32(ClusterData[6].y,  2, 22+3);
	Cluster.UV_Prec				= ClusterData[6].z;
	const uint MaterialEncoding = ClusterData[6].w;

	Cluster.ColorMin			= ClusterData[7].x;
	Cluster.ColorBits			= ClusterData[7].y;
	Cluster.GroupIndex			= ClusterData[7].z;			// Debug only

	// Material Table Range Encoding (32 bits)
	// uint TriStart        :  8;  // max 128 triangles
	// uint TriLength       :  8;  // max 128 triangles
	// uint MaterialIndex   :  6;  // max  64 materials
	// uint Padding         : 10;

	// Material Packed Range - Fast Path (32 bits)
	// uint Material0Index  : 6;  // max  64 materials (0:Material0Length)
	// uint Material1Index  : 6;  // max  64 materials (Material0Length:Material1Length)
	// uint Material2Index  : 6;  // max  64 materials (remainder)
	// uint Material0Length : 7;  // max 128 triangles (num minus one)
	// uint Material1Length : 7;  // max  64 triangles (materials are sorted, so at most 128/2)

	// Material Packed Range - Slow Path (32 bits)
	// uint BufferIndex     : 19; // 2^19 max value (tons, it's per prim)
	// uint BufferLength    : 6;  // max 64 ranges (num minus one)
	// uint Padding         : 7;  // always 127 for slow path. corresponds to Material1Length=127 in fast path

	BRANCH
	if (MaterialEncoding < 0xFE000000u)
	{
		// Fast inline path
		Cluster.MaterialTableOffset	= 0;
		Cluster.MaterialTableLength	= 0;		
		Cluster.Material0Index		= BitFieldExtractU32(MaterialEncoding, 6, 0);
		Cluster.Material1Index		= BitFieldExtractU32(MaterialEncoding, 6, 6);
		Cluster.Material2Index		= BitFieldExtractU32(MaterialEncoding, 6, 12);
		Cluster.Material0Length		= BitFieldExtractU32(MaterialEncoding, 7, 18) + 1;
		Cluster.Material1Length		= BitFieldExtractU32(MaterialEncoding, 7, 25);
	}
	else
	{
		// Slow global search path
		Cluster.MaterialTableOffset = BitFieldExtractU32(MaterialEncoding, 19, 0);
		Cluster.MaterialTableLength	= BitFieldExtractU32(MaterialEncoding, 6, 19) + 1;
		Cluster.Material0Index		= 0;
		Cluster.Material1Index		= 0;
		Cluster.Material2Index		= 0;
		Cluster.Material0Length		= 0;
		Cluster.Material1Length		= 0;
	}

	return Cluster;
}

FCluster GetCluster(uint PageIndex, uint ClusterIndex)
{
	uint NumClusters = ClusterPageHeaders.Load(PageIndex * 4);
	uint PageBaseAddress = (PageIndex << CLUSTER_PAGE_GPU_SIZE_BITS);
	
	FCluster Cluster = GetCluster(ClusterPageData, PageBaseAddress, ClusterIndex, NumClusters);
	Cluster.PageBaseAddress = PageBaseAddress;
	return Cluster;
}

// Decode triangle that is represented by one base index and two 5-bit offsets.
uint3 ReadTriangleIndices(FCluster Cluster, uint TriIndex)
{
	const uint BitsPerTriangle = Cluster.BitsPerIndex + 2 * 5;

	FBitStreamReaderState BitStreamReader = BitStreamReader_Create_Aligned(ClusterPageData, Cluster.PageBaseAddress + Cluster.IndexOffset, TriIndex * BitsPerTriangle, 8 + 2*5);

	uint BaseIndex = BitStreamReader_Read(BitStreamReader, Cluster.BitsPerIndex, 8);
	uint Delta0 = BitStreamReader_Read(BitStreamReader, 5, 5);
	uint Delta1 = BitStreamReader_Read(BitStreamReader, 5, 5);

	return BaseIndex + uint3(0, Delta0, Delta1);
}

void UnpackVisPixel(
	UlongType Pixel,
	out uint DepthInt,
	out uint VisibleClusterIndex, 
	out uint TriIndex
	)
{
	const uint2 Unpacked = UnpackUlongType(Pixel);
	VisibleClusterIndex = Unpacked.x >> 7;
	TriIndex = Unpacked.x & 0x7F;
	DepthInt = Unpacked.y;

	VisibleClusterIndex--;
}

void UnpackDbgPixel(
	UlongType Pixel,
	out uint DepthInt,
	out uint DebugValue
	)
{
	const uint2 Unpacked = UnpackUlongType(Pixel);
	DebugValue = Unpacked.x;
	DepthInt = Unpacked.y;
}

float3 UnpackPosition(uint2 Packed, FCluster Cluster)
{
	int3 Pos;
	Pos.x = BitFieldExtractU32(Packed.x, Cluster.PosBits.x, 0);

	Packed.x = BitAlignU32(Packed.y, Packed.x, Cluster.PosBits.x);
	Packed.y >>= Cluster.PosBits.x;
	Pos.y = BitFieldExtractU32(Packed.x, Cluster.PosBits.y, 0);

	Packed.x = BitAlignU32(Packed.y, Packed.x, Cluster.PosBits.y);
	Pos.z = BitFieldExtractU32(Packed.x, Cluster.PosBits.z, 0);

	return (Pos + Cluster.QuantizedPosStart) * Cluster.MeshBoundsDelta + Cluster.MeshBoundsMin;	// Get rid of MeshBoundsMin/MeshBoundsDelta once we remove of the old quantization.
}

uint2 GetPackedPosition(uint VertIndex, FCluster Cluster)
{
	const uint BitsPerVertex = Cluster.PosBits.x + Cluster.PosBits.y + Cluster.PosBits.z;
	const uint BitOffset = VertIndex * BitsPerVertex;
	uint3 Data = ClusterPageData.Load3(Cluster.PageBaseAddress + Cluster.PositionOffset + ((BitOffset >> 5) << 2));
	return uint2(BitAlignU32(Data.y, Data.x, BitOffset), BitAlignU32(Data.z, Data.y, BitOffset));
}

float3 DecodePosition(uint VertIndex, FCluster Cluster)
{
#if USE_UNCOMPRESSED_VERTEX_DATA
	return asfloat(ClusterPageData.Load3(Cluster.PageBaseAddress + Cluster.PositionOffset + VertIndex * 12));
#else
	const uint2 PackedPos = GetPackedPosition(VertIndex, Cluster);
	return UnpackPosition(PackedPos, Cluster);
#endif
}

FNaniteView UnpackNaniteView(FPackedNaniteView PackedView)
{
	FNaniteView NaniteView;
	
	NaniteView.TranslatedWorldToView		= PackedView.TranslatedWorldToView;
	NaniteView.TranslatedWorldToClip		= PackedView.TranslatedWorldToClip;
	NaniteView.ViewToClip					= PackedView.ViewToClip;
	NaniteView.ClipToWorld					= PackedView.ClipToWorld;
	
	NaniteView.PrevTranslatedWorldToView	= PackedView.PrevTranslatedWorldToView;
	NaniteView.PrevTranslatedWorldToClip	= PackedView.PrevTranslatedWorldToClip;
	NaniteView.PrevViewToClip				= PackedView.PrevViewToClip;
	NaniteView.PrevClipToWorld				= PackedView.PrevClipToWorld;

	NaniteView.ViewRect						= PackedView.ViewRect;
	NaniteView.ViewSizeAndInvSize			= PackedView.ViewSizeAndInvSize;
	NaniteView.ClipSpaceScaleOffset			= PackedView.ClipSpaceScaleOffset;
	NaniteView.PreViewTranslation			= PackedView.PreViewTranslation.xyz;
	NaniteView.PrevPreViewTranslation		= PackedView.PrevPreViewTranslation.xyz;
	NaniteView.WorldCameraOrigin			= PackedView.WorldCameraOrigin.xyz;
	NaniteView.ViewForward					= PackedView.ViewForwardAndNearPlane.xyz;
	NaniteView.NearPlane					= PackedView.ViewForwardAndNearPlane.w;
	NaniteView.LODScale						= PackedView.LODScales.x;
	NaniteView.LODScaleHW					= PackedView.LODScales.y;
	NaniteView.MinBoundsRadiusSq			= PackedView.MinBoundsRadiusSq;
	NaniteView.StreamingPriorityCategory	= PackedView.StreamingPriorityCategory_AndFlags & STREAMING_PRIORITY_CATEGORY_MASK;
	NaniteView.Flags						= PackedView.StreamingPriorityCategory_AndFlags >> NUM_STREAMING_PRIORITY_CATEGORY_BITS;
	
	NaniteView.TargetLayerIndex				= PackedView.TargetLayerIdX_AndMipLevelY_AndNumMipLevelsZ.x;
	NaniteView.TargetMipLevel				= PackedView.TargetLayerIdX_AndMipLevelY_AndNumMipLevelsZ.y;
	NaniteView.TargetNumMipLevels			= PackedView.TargetLayerIdX_AndMipLevelY_AndNumMipLevelsZ.z;
	NaniteView.TargetPrevLayerIndex			= PackedView.TargetLayerIdX_AndMipLevelY_AndNumMipLevelsZ.w;

	NaniteView.HZBTestViewRect				= PackedView.HZBTestViewRect;

	return NaniteView;
}

StructuredBuffer< FPackedNaniteView > InViews;
FNaniteView GetNaniteView( uint ViewIndex )
{
#if NANITE_USE_VIEW_UNIFORM_BUFFER
	FNaniteView NaniteView;

	NaniteView.TranslatedWorldToView		= View.TranslatedWorldToView;
	NaniteView.TranslatedWorldToClip		= View.TranslatedWorldToClip;
	NaniteView.ViewToClip					= View.ViewToClip;
	NaniteView.ClipToWorld					= View.ClipToWorld;
	
	NaniteView.PrevTranslatedWorldToView	= View.PrevTranslatedWorldToView;
	NaniteView.PrevTranslatedWorldToClip	= View.PrevTranslatedWorldToClip;
	NaniteView.PrevViewToClip				= View.PrevViewToClip;
	NaniteView.PrevClipToWorld				= View.PrevInvViewProj;

	NaniteView.ViewSizeAndInvSize			= View.ViewSizeAndInvSize;
	NaniteView.ViewRect						= int4(int2(View.ViewRectMin.xy + 0.5f), int2(View.ViewRectMin.xy + View.ViewSizeAndInvSize.xy + 0.5f));
	NaniteView.PreViewTranslation			= View.PreViewTranslation;
	NaniteView.PrevPreViewTranslation		= View.PrevPreViewTranslation;
	NaniteView.WorldCameraOrigin			= View.WorldCameraOrigin;
	NaniteView.ViewForward					= View.ViewForward;
	NaniteView.NearPlane					= View.NearPlane;
	NaniteView.LODScale						= 1.0f;
	NaniteView.LODScaleHW					= 1.0f;
	NaniteView.MinBoundsRadiusSq			= 0;
	NaniteView.StreamingPriorityCategory	= 3;
	NaniteView.Flags						= VIEW_FLAG_HZBTEST;
	
	NaniteView.TargetLayerIndex = 0;
	NaniteView.TargetMipLevel = 0;
	NaniteView.TargetNumMipLevels = 0;
	NaniteView.TargetPrevLayerIndex	= 0;

	NaniteView.HZBTestViewRect				= NaniteView.ViewRect;

#else // !NANITE_USE_VIEW_UNIFORM_BUFFER

#if NANITE_MULTI_VIEW
	FPackedNaniteView PackedView = InViews[ViewIndex];
#else
	FPackedNaniteView PackedView = InViews[0];
#endif
	FNaniteView NaniteView = UnpackNaniteView(PackedView);

#endif // NANITE_USE_VIEW_UNIFORM_BUFFER

	return NaniteView;
}
