// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenRadianceCacheCommon.ush
=============================================================================*/

#include "LumenOctahedralProbe.ush"

#ifndef LUMEN_HARDWARE_RAYTRACING
#define LUMEN_HARDWARE_RAYTRACING 0
#endif

#define RADIANCE_PROBE_MAX_CLIPMAPS 6
#define RADIANCE_CACHE_USE_INTERPOLATION 1
#define RADIANCE_CACHE_STORE_DEPTHS 1
#define INVALID_PROBE_INDEX 0xFFFFFFFF

Texture3D<uint> RadianceProbeIndirectionTexture;
Texture2D<float3> RadianceCacheFinalRadianceAtlas;
Texture2D<float3> RadianceCacheFinalIrradianceAtlas;
Texture2D<float2> RadianceCacheProbeOcclusionAtlas;

#if RADIANCE_CACHE_STORE_DEPTHS
Texture2D<float> RadianceCacheDepthAtlas;
#endif

#if LUMEN_HARDWARE_RAYTRACING
	// Temporary hack to access SHADER_PARAMETER_ARRAY in RGS
	// Workaround for error "subscripted value is not an array, matrix, or vector" in DXC when SHADER_PARAMETER_ARRAY is used in RGS
	#define RadianceProbeClipmapTMin  RGSRadianceCacheParameters.RadianceProbeClipmapTMin
	#define WorldPositionToRadianceProbeCoordScale RGSRadianceCacheParameters.WorldPositionToRadianceProbeCoordScale
	#define WorldPositionToRadianceProbeCoordBias RGSRadianceCacheParameters.WorldPositionToRadianceProbeCoordBias
	#define RadianceProbeCoordToWorldPositionScale RGSRadianceCacheParameters.RadianceProbeCoordToWorldPositionScale
	#define RadianceProbeCoordToWorldPositionBias RGSRadianceCacheParameters.RadianceProbeCoordToWorldPositionBias
#else
	float RadianceProbeClipmapTMin[RADIANCE_PROBE_MAX_CLIPMAPS];
	float WorldPositionToRadianceProbeCoordScale[RADIANCE_PROBE_MAX_CLIPMAPS];
	float3 WorldPositionToRadianceProbeCoordBias[RADIANCE_PROBE_MAX_CLIPMAPS];
	float RadianceProbeCoordToWorldPositionScale[RADIANCE_PROBE_MAX_CLIPMAPS];
	float3 RadianceProbeCoordToWorldPositionBias[RADIANCE_PROBE_MAX_CLIPMAPS];
#endif

float ReprojectionRadiusScale;

uint2 ProbeAtlasResolutionInProbes;
float2 InvProbeFinalRadianceAtlasResolution;
float2 InvProbeFinalIrradianceAtlasResolution;
float2 InvProbeDepthAtlasResolution;

uint NumRadianceProbeClipmaps;
uint RadianceProbeClipmapResolution;
// Resolution of Octahedral layout during tracing
uint RadianceProbeResolution; 
// Resolution of Octahedral layout during sampling
uint FinalProbeResolution;

uint CalculateIrradiance;
uint IrradianceProbeResolution; 
// Resolution of Octahedral layout for sampling
uint OcclusionProbeResolution;

uint FinalRadianceAtlasMaxMip;
uint OverrideCacheOcclusionLighting;
uint ShowBlackRadianceCacheLighting;

#define USED_PROBE_INDEX 0xFFFFFFFE

StructuredBuffer<float4> ProbeWorldOffset;

float3 GetProbeWorldPosition(uint3 ProbeCoord, uint ClipmapIndex, uint ProbeIndex)
{
	float3 ProbeWorldPosition = ProbeCoord * RadianceProbeCoordToWorldPositionScale[ClipmapIndex] + RadianceProbeCoordToWorldPositionBias[ClipmapIndex];
	return ProbeWorldPosition + ProbeWorldOffset[ProbeIndex].xyz;
}

RWTexture3D<uint> RWRadianceProbeIndirectionTexture;

void MarkPositionUsedInIndirectionTexture(float3 WorldPosition, uint ClipmapIndex)
{
#if RADIANCE_CACHE_USE_INTERPOLATION
	int3 BottomCornerProbeCoord = WorldPosition * WorldPositionToRadianceProbeCoordScale[ClipmapIndex] + WorldPositionToRadianceProbeCoordBias[ClipmapIndex] - .5f;
	int3 IndirectionTextureCoord = BottomCornerProbeCoord + int3(ClipmapIndex * RadianceProbeClipmapResolution, 0, 0);

	RWRadianceProbeIndirectionTexture[IndirectionTextureCoord] = USED_PROBE_INDEX;
	RWRadianceProbeIndirectionTexture[IndirectionTextureCoord + int3(0, 0, 1)] = USED_PROBE_INDEX;
	RWRadianceProbeIndirectionTexture[IndirectionTextureCoord + int3(0, 1, 0)] = USED_PROBE_INDEX;
	RWRadianceProbeIndirectionTexture[IndirectionTextureCoord + int3(0, 1, 1)] = USED_PROBE_INDEX;
	RWRadianceProbeIndirectionTexture[IndirectionTextureCoord + int3(1, 0, 0)] = USED_PROBE_INDEX;
	RWRadianceProbeIndirectionTexture[IndirectionTextureCoord + int3(1, 0, 1)] = USED_PROBE_INDEX;
	RWRadianceProbeIndirectionTexture[IndirectionTextureCoord + int3(1, 1, 0)] = USED_PROBE_INDEX;
	RWRadianceProbeIndirectionTexture[IndirectionTextureCoord + int3(1, 1, 1)] = USED_PROBE_INDEX;
#else
	int3 ProbeCoord = WorldPosition * WorldPositionToRadianceProbeCoordScale[ClipmapIndex] + WorldPositionToRadianceProbeCoordBias[ClipmapIndex];
	int3 IndirectionTextureCoord = ProbeCoord + int3(ClipmapIndex * RadianceProbeClipmapResolution, 0, 0);
	RWRadianceProbeIndirectionTexture[IndirectionTextureCoord] = USED_PROBE_INDEX;
#endif
}

uint GetRadianceProbeClipmap(float3 WorldSpacePosition)
{
	uint ClipmapIndex = 0;
	for (; ClipmapIndex < NumRadianceProbeClipmaps; ++ClipmapIndex)
	{
		float3 ProbeCoordFloat = WorldSpacePosition * WorldPositionToRadianceProbeCoordScale[ClipmapIndex] + WorldPositionToRadianceProbeCoordBias[ClipmapIndex];

		int3 ProbeMinCoord;
		int3 ProbeMaxCoord;

#if RADIANCE_CACHE_USE_INTERPOLATION
		ProbeMinCoord = ProbeCoordFloat - .5f;
		ProbeMaxCoord = ProbeMinCoord + 1;
#else
		ProbeMinCoord = ProbeCoordFloat;
		ProbeMaxCoord = ProbeMinCoord;
#endif

		if (all(ProbeMinCoord >= 0) && all(ProbeMaxCoord < (int3)RadianceProbeClipmapResolution))
		{
			return ClipmapIndex;
		}
	}

	return NumRadianceProbeClipmaps;
}

float GetRadianceProbeTMin(uint ClipmapIndex)
{
	return RadianceProbeClipmapTMin[ClipmapIndex];
}

float GetRadianceProbeOcclusionDistanceWithInterpolation(float3 RayOrigin, float3 RayDirection, out bool bCoveredByRadianceCache)
{
	uint ClipmapIndex = GetRadianceProbeClipmap(RayOrigin);

	if (ClipmapIndex < NumRadianceProbeClipmaps)
	{
		bCoveredByRadianceCache = true;

		float CellOcclusionDistance = RadianceProbeCoordToWorldPositionScale[ClipmapIndex] * sqrt(3.0f);
		return GetRadianceProbeTMin(ClipmapIndex) + CellOcclusionDistance;
	}
	else
	{
		bCoveredByRadianceCache = false;
		return 10000000.0f;
	}
}

float3 SampleRadianceCacheProbe(uint ProbeIndex, float3 WorldSpaceDirection, float MipLevel)
{
	float2 ProbeUV = DirectionToOctahedralMap(WorldSpaceDirection);

#define VISUALIZE_PROBE_DEPTH 0
#if VISUALIZE_PROBE_DEPTH && RADIANCE_CACHE_STORE_DEPTHS
	uint2 ProbeAtlasCoord = RadianceProbeResolution * uint2(ProbeIndex % ProbeAtlasResolutionInProbes.x, ProbeIndex / ProbeAtlasResolutionInProbes.x);
	float2 ProbeTexelCoord = ProbeUV * RadianceProbeResolution;
	float2 ProbeAtlasUV = (ProbeAtlasCoord + ProbeTexelCoord) * InvProbeDepthAtlasResolution;
	return RadianceCacheDepthAtlas.SampleLevel(GlobalPointClampedSampler, ProbeAtlasUV, MipLevel).x / 10000.0f;
#else
	uint2 ProbeAtlasCoord = FinalProbeResolution * uint2(ProbeIndex % ProbeAtlasResolutionInProbes.x, ProbeIndex / ProbeAtlasResolutionInProbes.x);
	float2 ProbeTexelCoord = ProbeUV * RadianceProbeResolution + (1 << FinalRadianceAtlasMaxMip);
	float2 ProbeAtlasUV = (ProbeAtlasCoord + ProbeTexelCoord) * InvProbeFinalRadianceAtlasResolution;

	float3 UnmappedDebugColor = 0.0f;
	// Show bright green when an unallocated probe is sampled
	UnmappedDebugColor = float3(0.0f, 10.0f, 0.0f);
	return ProbeIndex == INVALID_PROBE_INDEX ? UnmappedDebugColor : RadianceCacheFinalRadianceAtlas.SampleLevel(GlobalBilinearClampedSampler, ProbeAtlasUV, MipLevel);
#endif
}

uint GetProbeIndexFromIndirectionTexture(uint3 ProbeCoord, uint ClipmapIndex)
{
	uint3 ProbeIndirectionTextureCoord = uint3(ProbeCoord.x + ClipmapIndex * RadianceProbeClipmapResolution, ProbeCoord.yz);
	return RadianceProbeIndirectionTexture.Load(uint4(ProbeIndirectionTextureCoord, 0));
}

float3 SampleRadianceCacheProbeWithParallaxCorrection(uint3 ProbeCoord, uint ProbeClipmapIndex, float3 WorldSpacePosition, float3 WorldSpaceDirection, float MipLevel)
{
	float ProbeTMin = GetRadianceProbeTMin(ProbeClipmapIndex);
	uint ProbeIndex = GetProbeIndexFromIndirectionTexture(ProbeCoord, ProbeClipmapIndex);
	float3 ProbeWorldPosition = GetProbeWorldPosition(ProbeCoord, ProbeClipmapIndex, ProbeIndex);

	float3 ReprojectedDirection = WorldSpaceDirection;

#define SIMPLE_SPHERE_PARALLAX 1
#define TRACE_THROUGH_PROBE_DEPTHS_REFERENCE 0

#if SIMPLE_SPHERE_PARALLAX

	float ReprojectionRadius = ReprojectionRadiusScale * ProbeTMin;
	float3 IntersectionPosition = WorldSpacePosition + WorldSpaceDirection * RayIntersectSphere(WorldSpacePosition, WorldSpaceDirection, float4(ProbeWorldPosition, ReprojectionRadius)).y;
	ReprojectedDirection = IntersectionPosition - ProbeWorldPosition;

#elif TRACE_THROUGH_PROBE_DEPTHS_REFERENCE && RADIANCE_CACHE_STORE_DEPTHS
	//@note - no depth mips implemented
	float3 ProbeTraceStart = WorldSpacePosition + WorldSpaceDirection * RayIntersectSphere(WorldSpacePosition, WorldSpaceDirection, float4(ProbeWorldPosition, ProbeTMin)).y;
	float3 ProbeTraceEnd = ProbeWorldPosition + WorldSpaceDirection * 10000.0f;
	float3 ProbeTraceDirection = ProbeTraceEnd - ProbeTraceStart;
	uint2 ProbeAtlasCoord = RadianceProbeResolution * uint2(ProbeIndex % ProbeAtlasResolutionInProbes.x, ProbeIndex / ProbeAtlasResolutionInProbes.x);

	float NumSamples = 100.0f;

	for (float StepIndex = 0; StepIndex < NumSamples; StepIndex++)
	{
		float3 StepPosition = ProbeTraceStart + StepIndex / (NumSamples - 1) * ProbeTraceDirection;
		float3 ProbeToStepPosition = StepPosition - ProbeWorldPosition;
		float2 ProbeUV = DirectionToOctahedralMap(ProbeToStepPosition);
		float2 ProbeAtlasUV = (ProbeAtlasCoord + ProbeUV * RadianceProbeResolution) * InvProbeDepthAtlasResolution;
		float StepHitDistanceFromProbe = RadianceCacheDepthAtlas.SampleLevel(GlobalPointClampedSampler, ProbeAtlasUV, MipLevel).x;
		float StepRayDistanceFromProbeSq = dot(ProbeToStepPosition, ProbeToStepPosition);

		if (StepHitDistanceFromProbe * StepHitDistanceFromProbe < StepRayDistanceFromProbeSq)
		{
			ReprojectedDirection = ProbeToStepPosition;
			break;
		}
	}

#endif

	return SampleRadianceCacheProbe(ProbeIndex, ReprojectedDirection, MipLevel);
}

float3 SampleRadianceCacheInterpolated(float3 WorldSpacePosition, float3 WorldSpaceDirection, float ConeHalfAngle, float3 Random)
{
	uint ClipmapIndex = GetRadianceProbeClipmap(WorldSpacePosition);

	if (ClipmapIndex < NumRadianceProbeClipmaps)
	{
		float3 ProbeCoordFloat = WorldSpacePosition * WorldPositionToRadianceProbeCoordScale[ClipmapIndex] + WorldPositionToRadianceProbeCoordBias[ClipmapIndex];

		//float ConeHalfAngle = acosFast(1.0f - NumTexels * NumTexels / (float)(RadianceProbeResolution * RadianceProbeResolution));
		float NumTexels = sqrt(1.0f - cos(ConeHalfAngle)) * RadianceProbeResolution;
		float MipLevel = clamp(log2(NumTexels), 0, (float)FinalRadianceAtlasMaxMip);

#if RADIANCE_CACHE_USE_INTERPOLATION
		float3 CornerProbeCoordFloat = ProbeCoordFloat - .5f;
		int3 CornerProbeCoord = CornerProbeCoordFloat;
		float3 LerpAlphas = frac(CornerProbeCoordFloat);

#define STOCHASTIC_INTERPOLATION 0
#if STOCHASTIC_INTERPOLATION
		int3 StochasticProbeCoord = CornerProbeCoord + int3(Random < LerpAlphas ? 1 : 0);
		return SampleRadianceCacheProbeWithParallaxCorrection(StochasticProbeCoord, ClipmapIndex, WorldSpacePosition, WorldSpaceDirection, MipLevel);
#else
		//@todo - parallax correct using a single sphere bounding all the probes
		float3 Lighting000 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(0, 0, 0), ClipmapIndex, WorldSpacePosition, WorldSpaceDirection, MipLevel);
		float3 Lighting001 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(0, 0, 1), ClipmapIndex, WorldSpacePosition, WorldSpaceDirection, MipLevel);
		float3 Lighting010 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(0, 1, 0), ClipmapIndex, WorldSpacePosition, WorldSpaceDirection, MipLevel);
		float3 Lighting011 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(0, 1, 1), ClipmapIndex, WorldSpacePosition, WorldSpaceDirection, MipLevel);
		float3 Lighting100 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(1, 0, 0), ClipmapIndex, WorldSpacePosition, WorldSpaceDirection, MipLevel);
		float3 Lighting101 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(1, 0, 1), ClipmapIndex, WorldSpacePosition, WorldSpaceDirection, MipLevel);
		float3 Lighting110 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(1, 1, 0), ClipmapIndex, WorldSpacePosition, WorldSpaceDirection, MipLevel);
		float3 Lighting111 = SampleRadianceCacheProbeWithParallaxCorrection(CornerProbeCoord + int3(1, 1, 1), ClipmapIndex, WorldSpacePosition, WorldSpaceDirection, MipLevel);

		float3 ZLerp00 = lerp(Lighting000, Lighting001, LerpAlphas.z);
		float3 ZLerp01 = lerp(Lighting010, Lighting011, LerpAlphas.z);
		float3 ZLerp10 = lerp(Lighting100, Lighting101, LerpAlphas.z);
		float3 ZLerp11 = lerp(Lighting110, Lighting111, LerpAlphas.z);

		float3 YLerp0 = lerp(ZLerp00, ZLerp01, LerpAlphas.y);
		float3 YLerp1 = lerp(ZLerp10, ZLerp11, LerpAlphas.y);

		return lerp(YLerp0, YLerp1, LerpAlphas.x);
#endif

#else
		int3 ProbeCoord = ProbeCoordFloat;
		uint ProbeIndex = GetProbeIndexFromIndirectionTexture(ProbeCoord, ClipmapIndex);
		return SampleRadianceCacheProbe(ProbeIndex, WorldSpaceDirection, MipLevel);
#endif
	}

	return float3(0.0f, 0.0f, 0.0f);
}

void SampleRadianceCacheAndApply(float3 WorldSpacePosition, float3 WorldSpaceDirection, float ConeHalfAngle, float3 Random, inout float3 Lighting, inout float Transparency)
{
	float3 RadianceCacheLighting = SampleRadianceCacheInterpolated(WorldSpacePosition, WorldSpaceDirection, ConeHalfAngle, Random);

	if (OverrideCacheOcclusionLighting > 0)
	{
		Lighting = RadianceCacheLighting;
	}
	else if (ShowBlackRadianceCacheLighting == 0)
	{
		Lighting += RadianceCacheLighting * Transparency;
	}
	
	Transparency = 0.0f;
}

float3 SampleIrradianceCacheProbe(uint ProbeIndex, float3 WorldSpaceDirection)
{
	//@todo - move out of loop
	float2 ProbeUV = DirectionToOctahedralMap(WorldSpaceDirection);

	uint FinalIrradianceProbeResolution = IrradianceProbeResolution + 2 * (1 << FinalRadianceAtlasMaxMip);
	uint2 ProbeAtlasCoord = FinalIrradianceProbeResolution * uint2(ProbeIndex % ProbeAtlasResolutionInProbes.x, ProbeIndex / ProbeAtlasResolutionInProbes.x);
	float2 ProbeTexelCoord = ProbeUV * IrradianceProbeResolution + (1 << FinalRadianceAtlasMaxMip);
	float2 ProbeAtlasUV = (ProbeAtlasCoord + ProbeTexelCoord) * InvProbeFinalIrradianceAtlasResolution;

	float3 UnmappedDebugColor = 0.0f;
	// Show bright green when an unallocated probe is sampled
	UnmappedDebugColor = float3(0.0f, 10.0f, 0.0f);
	return ProbeIndex == INVALID_PROBE_INDEX ? UnmappedDebugColor : RadianceCacheFinalIrradianceAtlas.SampleLevel(GlobalBilinearClampedSampler, ProbeAtlasUV, 0.0f);
}

float2 SampleProbeOcclusion(uint ProbeIndex, float3 WorldSpaceDirection)
{
	float2 ProbeUV = DirectionToOctahedralMap(WorldSpaceDirection);

	uint FinalOcclusionProbeResolution = OcclusionProbeResolution + 2 * (1 << FinalRadianceAtlasMaxMip);
	uint2 ProbeAtlasCoord = FinalOcclusionProbeResolution * uint2(ProbeIndex % ProbeAtlasResolutionInProbes.x, ProbeIndex / ProbeAtlasResolutionInProbes.x);
	float2 ProbeTexelCoord = ProbeUV * OcclusionProbeResolution + (1 << FinalRadianceAtlasMaxMip);
	float2 ProbeAtlasUV = (ProbeAtlasCoord + ProbeTexelCoord) / float2(ProbeAtlasResolutionInProbes * FinalOcclusionProbeResolution);

	return RadianceCacheProbeOcclusionAtlas.SampleLevel(GlobalBilinearClampedSampler, ProbeAtlasUV, 0.0f);
}

float3 SampleIrradianceCacheProbeCoord(uint3 ProbeCoord, uint ProbeClipmapIndex, float3 WorldSpaceDirection)
{
	uint ProbeIndex = GetProbeIndexFromIndirectionTexture(ProbeCoord, ProbeClipmapIndex);
	return SampleIrradianceCacheProbe(ProbeIndex, WorldSpaceDirection);
}

float3 SampleIrradianceCacheInterpolated(float3 WorldSpacePosition, float3 WorldSpaceDirection, float3 BiasOffset, uint ClipmapIndex)
{
	float3 ProbeCoordFloat = WorldSpacePosition * WorldPositionToRadianceProbeCoordScale[ClipmapIndex] + WorldPositionToRadianceProbeCoordBias[ClipmapIndex];

	float3 CornerProbeCoordFloat = ProbeCoordFloat - .5f;
	int3 CornerProbeCoord = CornerProbeCoordFloat;
	float3 LerpAlphas = frac(CornerProbeCoordFloat);

	float3 Irradiance = 0;
	float TotalWeight = 0;

#define PROBE_OCCLUSION_INTERPOLATION 1
#if PROBE_OCCLUSION_INTERPOLATION

	for (uint NeighborIndex = 0; NeighborIndex < 8; NeighborIndex++)
	{
		uint3 ProbeOffset = uint3((NeighborIndex & 4) >> 2, (NeighborIndex & 2) >> 1, NeighborIndex & 1);
		uint3 ProbeCoord = CornerProbeCoord + ProbeOffset;
		uint ProbeIndex = GetProbeIndexFromIndirectionTexture(ProbeCoord, ClipmapIndex);
		float3 ProbeWorldPosition = GetProbeWorldPosition(ProbeCoord, ClipmapIndex, ProbeIndex);
		float3 SamplePosition = WorldSpacePosition + BiasOffset;
		float3 SamplePositionToProbe = ProbeWorldPosition - SamplePosition;
		float DistanceToProbe = length(SamplePositionToProbe);

		float SoftFalloff = (dot(normalize(ProbeWorldPosition - WorldSpacePosition), WorldSpaceDirection) + 1) * .5f;
		float Weight = SoftFalloff * SoftFalloff + .2f;

		//@todo - trilinear weight ignores probe offset
		float3 TrilinearWeights = max(ProbeOffset > 0 ? LerpAlphas : 1 - LerpAlphas, .001f);
		Weight *= TrilinearWeights.x * TrilinearWeights.y * TrilinearWeights.z;

		float2 MeanAndMeanSq = SampleProbeOcclusion(ProbeIndex, -SamplePositionToProbe);

		if (DistanceToProbe > MeanAndMeanSq.x)
		{
			float Variance = abs(Square(MeanAndMeanSq.x) - MeanAndMeanSq.y);
			float VisibilityWeight = Variance / (Variance + Square(DistanceToProbe - MeanAndMeanSq.x));
			Weight *= max(VisibilityWeight * VisibilityWeight * VisibilityWeight, 0);
		}

		float WeightThreshold = .2f;

		if (Weight < WeightThreshold)
		{
			Weight *= Square(Weight) / Square(WeightThreshold);
		}

		float3 SampleIrradiance = SampleIrradianceCacheProbe(ProbeIndex, WorldSpaceDirection);

		Irradiance += sqrt(SampleIrradiance) * Weight;
		TotalWeight += Weight;
	}

	Irradiance = Square(Irradiance / TotalWeight);

#else
	float3 Lighting000 = SampleIrradianceCacheProbeCoord(CornerProbeCoord + int3(0, 0, 0), ClipmapIndex, WorldSpaceDirection);
	float3 Lighting001 = SampleIrradianceCacheProbeCoord(CornerProbeCoord + int3(0, 0, 1), ClipmapIndex, WorldSpaceDirection);
	float3 Lighting010 = SampleIrradianceCacheProbeCoord(CornerProbeCoord + int3(0, 1, 0), ClipmapIndex, WorldSpaceDirection);
	float3 Lighting011 = SampleIrradianceCacheProbeCoord(CornerProbeCoord + int3(0, 1, 1), ClipmapIndex, WorldSpaceDirection);
	float3 Lighting100 = SampleIrradianceCacheProbeCoord(CornerProbeCoord + int3(1, 0, 0), ClipmapIndex, WorldSpaceDirection);
	float3 Lighting101 = SampleIrradianceCacheProbeCoord(CornerProbeCoord + int3(1, 0, 1), ClipmapIndex, WorldSpaceDirection);
	float3 Lighting110 = SampleIrradianceCacheProbeCoord(CornerProbeCoord + int3(1, 1, 0), ClipmapIndex, WorldSpaceDirection);
	float3 Lighting111 = SampleIrradianceCacheProbeCoord(CornerProbeCoord + int3(1, 1, 1), ClipmapIndex, WorldSpaceDirection);

	float3 ZLerp00 = lerp(Lighting000, Lighting001, LerpAlphas.z);
	float3 ZLerp01 = lerp(Lighting010, Lighting011, LerpAlphas.z);
	float3 ZLerp10 = lerp(Lighting100, Lighting101, LerpAlphas.z);
	float3 ZLerp11 = lerp(Lighting110, Lighting111, LerpAlphas.z);

	float3 YLerp0 = lerp(ZLerp00, ZLerp01, LerpAlphas.y);
	float3 YLerp1 = lerp(ZLerp10, ZLerp11, LerpAlphas.y);

	Irradiance = lerp(YLerp0, YLerp1, LerpAlphas.x);
#endif

	return Irradiance;
}