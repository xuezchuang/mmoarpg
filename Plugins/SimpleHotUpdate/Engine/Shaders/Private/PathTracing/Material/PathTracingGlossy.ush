// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================================
Glossy.usf: Microfacet GGX BRDF sampling functions 
===============================================================================================*/

#pragma once

// be conservative since the GPU may be aggressive with floating point optimizations
#define GGX_MIN_ROUGHNESS 0.01
#define GGX_MIN_ANISOTROPY 0.001 // ignore anisotropy below this amount

float3x3 GetGGXBasis(float Roughness, float Anisotropy, float3 WorldNormal, float3 WorldTangent, out float2 Alpha)
{
	Roughness = max(Roughness, GGX_MIN_ROUGHNESS);
	float3x3 Basis;
	if (abs(Anisotropy) >= GGX_MIN_ANISOTROPY)
	{
		// Material is anisotropic, our shading frame should use the tangent vector
		GetAnisotropicRoughness(Roughness * Roughness, Anisotropy, Alpha.x, Alpha.y);
		float3 X = WorldTangent;
		float3 Y = normalize(cross(WorldNormal, X));
		Basis = float3x3(cross(Y, WorldNormal), Y, WorldNormal);
	}
	else
	{
		// No anisotropy, just pick an arbitrary basis
		Alpha = Roughness * Roughness;
		Basis = GetTangentBasis(WorldNormal);
	}
	return Basis;
}

float3x3 GetGGXBasis(float Roughness, float3 WorldNormal, out float2 Alpha)
{
	// No anisotropy, just pick an arbitrary basis
	Roughness = max(Roughness, GGX_MIN_ROUGHNESS);
	Alpha = Roughness * Roughness;
	return GetTangentBasis(WorldNormal);
}

float3 GGXHelper(float3 L, float3 V, float3 H, float2 Alpha)
{
	// TODO: Can this be further simplified / unified with other GGX routines?
	const float CosThetaM4 = Pow2(H.z);
	const float TanThetaM2 = (Pow2(H.x / Alpha.x) + Pow2(H.y / Alpha.y)) / Pow2(H.z);
	const float D = 1 / (PI * Pow2(1 + TanThetaM2) * Alpha.x * Alpha.y * CosThetaM4);
	const float Lambda_o = 0.5 * (-1.0 + sqrt(1.0 + (Pow2(L.x * Alpha.x) + Pow2(L.y * Alpha.y)) / Pow2(L.z)));
	const float Lambda_i = 0.5 * (-1.0 + sqrt(1.0 + (Pow2(V.x * Alpha.x) + Pow2(V.y * Alpha.y)) / Pow2(V.z)));
	const float G2 = 1 / (Lambda_i + Lambda_o + 1);
	const float G1 = 1 / (Lambda_i + 1);

	return float3(D, G2, G1);
}


// Compute GGX lobe Weight and Pdf (without Fresnel term) given a set of vectors in local space (Z up)
float2 GGXEvalReflection(float3 L, float3 V, float3 H, float2 Alpha)
{
	const float NoL = saturate(L.z);
	const float NoV = saturate(V.z);

	if (NoL > 0 && NoV > 0)
	{
		const float3 Result = GGXHelper(L, V, H, Alpha);
		const float D = Result.x;
		const float G2 = Result.y;
		const float G1 = Result.z;

		const float Weight = G2 / G1;
		const float Pdf = (G1 * D * 0.25f) / NoV;

		return float2(Weight, Pdf);
	}
	return 0;
}


// Compute GGX lobe Weight and Pdf (without Fresnel term) given a set of vectors in local space (Z up)
float2 GGXEvalRefraction(float3 L, float3 V, float3 H, float2 Alpha, float Eta)
{
	const float NoV = saturate(V.z);
	const float NoL = saturate(-L.z); // NOTE: L should point down

	// This checks that V and L point in opposite sides 
	if (NoL > 0 && NoV > 0)
	{
		const float3 Result = GGXHelper(L, V, H, Alpha);
		const float D = Result.x;
		const float G2 = Result.y;
		const float G1 = Result.z;

		const float VoH = dot(V, H);
		const float LoH = dot(L, H);
		const float3 Ht = (Eta * L + V);

		const float Weight = G2 / G1;
		const float Pdf = (abs(LoH * VoH) * (Eta * Eta) * (G1 * D)) / (dot(Ht, Ht) * NoV);

		return float2(Weight, Pdf);
	}
	return 0;
}
