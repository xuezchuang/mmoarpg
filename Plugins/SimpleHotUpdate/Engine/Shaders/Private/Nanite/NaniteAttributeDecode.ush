// Copyright Epic Games, Inc. All Rights Reserved.

#pragma once

#include "NaniteDataDecode.ush"

#define MAX_NANITE_UVS								4		// must match define in NaniteResources.h
#define MAX_TEXCOORD_QUANTIZATION_BITS				15		// must match define in NaniteResources.h
#define MAX_COLOR_QUANTIZATION_BITS					8		// must match define in NaniteResources.h

#define NORMAL_QUANTIZATION_BITS					9

#define VERTEX_COLOR_MODE_WHITE						0
#define VERTEX_COLOR_MODE_CONSTANT					1
#define VERTEX_COLOR_MODE_VARIABLE					2

struct FNaniteAttributeData
{
	/** Interpolated vertex color, in linear color space. */
	half4 VertexColor;
	half4 VertexColor_DDX;
	half4 VertexColor_DDY;

	/** Orthonormal rotation-only transform from tangent space to world space. */
	half3x3 TangentToWorld;

	float2 TexCoords[16];
	float2 TexCoords_DDX[16];
	float2 TexCoords_DDY[16];

	half UnMirrored;
};

#define SIZEOF_UV_RANGE	32
struct FUVRange
{
	float2	Min;
	float2	Scale;
	uint2	GapStart;
	uint2	GapLength;
};

FUVRange GetUVRange(ByteAddressBuffer InputBuffer, uint StartOffset, uint Index)
{
	uint Offset = StartOffset + Index * SIZEOF_UV_RANGE;
	uint4 Data[2];
	Data[0] = InputBuffer.Load4(Offset);
	Data[1] = InputBuffer.Load4(Offset + 16);

	FUVRange Range;
	Range.Min =			asfloat(Data[0].xy);
	Range.Scale =		asfloat(Data[0].zw);
	Range.GapStart =	Data[1].xy;
	Range.GapLength =	Data[1].zw;
	return Range;
}

float2 UnpackTexCoord(uint2 Packed, FUVRange UVRange)
{
	uint2 T = Packed + ((Packed >= UVRange.GapStart) ? UVRange.GapLength : 0u);
	return float2(T) * UVRange.Scale + UVRange.Min;
}

float3 UnpackNormal(uint Packed, uint Bits)
{
	uint Mask = BitFieldMaskU32(Bits, 0);
	float2 F = uint2(BitFieldExtractU32(Packed, Bits, 0), BitFieldExtractU32(Packed, Bits, Bits)) * (2.0f / Mask) - 1.0f;
	float3 N = float3(F.xy, 1.0 - abs(F.x) - abs(F.y));
	float T = saturate(-N.z);
	N.xy += N.xy >= 0.0 ? -T : T;
	return N;
}

struct FBarycentrics
{
	float3 UVW;
	float3 UVW_dx;
	float3 UVW_dy;
};

/** Calculates perspective correct barycentric coordinates and partial derivatives using screen derivatives. */
FBarycentrics CalculateTriangleBarycentrics(float2 PixelClip, float4 PointClip0, float4 PointClip1, float4 PointClip2, float2 ViewInvSize)
{
	FBarycentrics Result;

	float3 Pos0 = PointClip0.xyz / PointClip0.w;
	float3 Pos1 = PointClip1.xyz / PointClip1.w;
	float3 Pos2 = PointClip2.xyz / PointClip2.w;

	float3 RcpW = rcp(float3(PointClip0.w, PointClip1.w, PointClip2.w));

	float3 Pos120X = float3(Pos1.x, Pos2.x, Pos0.x);
	float3 Pos120Y = float3(Pos1.y, Pos2.y, Pos0.y);
	float3 Pos201X = float3(Pos2.x, Pos0.x, Pos1.x);
	float3 Pos201Y = float3(Pos2.y, Pos0.y, Pos1.y);

	float3 C_dx = Pos201Y - Pos120Y;
	float3 C_dy = Pos120X - Pos201X;

	float3 C = C_dx * (PixelClip.x - Pos120X) + C_dy * (PixelClip.y - Pos120Y);	// Evaluate the 3 edge functions
	float3 G = C * RcpW;

	float H = dot(C, RcpW);
	float RcpH = rcp(H);

	// UVW = C * RcpW / dot(C, RcpW)
	Result.UVW = G * RcpH;

	// Texture coordinate derivatives:
	// UVW = G / H where G = C * RcpW and H = dot(C, RcpW)
	// UVW' = (G' * H - G * H') / H^2
	// float2 TexCoordDX = UVW_dx.y * TexCoord10 + UVW_dx.z * TexCoord20;
	// float2 TexCoordDY = UVW_dy.y * TexCoord10 + UVW_dy.z * TexCoord20;
	float3 G_dx = C_dx * RcpW;
	float3 G_dy = C_dy * RcpW;

	float H_dx = dot(C_dx, RcpW);
	float H_dy = dot(C_dy, RcpW);

	Result.UVW_dx = (G_dx * H - G * H_dx) * (RcpH * RcpH) * ( 2.0f * ViewInvSize.x);
	Result.UVW_dy = (G_dy * H - G * H_dy) * (RcpH * RcpH) * (-2.0f * ViewInvSize.y);

	return Result;
}

uint CalculateMaxAttributeBits(uint NumTexCoordInterpolators)
{
	return (2 * NORMAL_QUANTIZATION_BITS + 4 * MAX_COLOR_QUANTIZATION_BITS + NumTexCoordInterpolators * (2 * MAX_TEXCOORD_QUANTIZATION_BITS));
}

bool IsMaterialFastPath(FCluster InCluster)
{
	return (InCluster.Material0Length > 0);
}

uint GetRelativeMaterialIndex(FCluster InCluster, uint InTriIndex)
{
	uint MaterialIndex = 0xFFFFFFFF;

	BRANCH
	if (IsMaterialFastPath(InCluster))
	{
		if (InTriIndex < InCluster.Material0Length)
		{
			MaterialIndex = InCluster.Material0Index;
		}
		else if (InTriIndex < (InCluster.Material0Length + InCluster.Material1Length))
		{
			MaterialIndex = InCluster.Material1Index;
		}
		else
		{
			MaterialIndex = InCluster.Material2Index;
		}
	}
	else
	{
		uint TableOffset = InCluster.PageBaseAddress + InCluster.MaterialTableOffset * 4;
		LOOP for (uint TableEntry = 0; TableEntry < InCluster.MaterialTableLength; ++TableEntry)
		{
			uint EncodedRange = ClusterPageData.Load(TableOffset);
			TableOffset += 4;

			// uint32 TriStart      :  8; // max 128 triangles
			// uint32 TriLength     :  8; // max 128 triangles
			// uint32 MaterialIndex :  6; // max  64 materials
			// uint32 Padding       : 10;

			const uint TriStart  = BitFieldExtractU32(EncodedRange, 8, 0);
			const uint TriLength = BitFieldExtractU32(EncodedRange, 8, 8);
			if (InTriIndex >= TriStart && InTriIndex < (TriStart + TriLength))
			{
				MaterialIndex = BitFieldExtractU32(EncodedRange, 6, 16);
				break;
			}
		}
	}

	return MaterialIndex;
}

uint RemapMaterialIndexToOffset(uint InPrimitiveIndex, uint InMaterialIndex)
{
	// Remap local primitive material indices (i.e. 0...8) to global indices of all primitives in current scene
	const uint MaxMaterials = 64;
	const uint RemapOffset = (InPrimitiveIndex * MaxMaterials * 4) + (InMaterialIndex * 4);
	return RemapOffset;
}

uint RemapMaterialIndexToId(uint InPrimitiveIndex, uint InMaterialIndex, ByteAddressBuffer InMaterialTable)
{
	const uint RemapOffset = RemapMaterialIndexToOffset(InPrimitiveIndex, InMaterialIndex);
	const uint MaterialId = InMaterialTable.Load(RemapOffset);
	return MaterialId;
}

uint GetMaterialDepthId(
	FCluster InCluster,
	uint InPrimitiveIndex,
	uint InTriIndex,
	ByteAddressBuffer InMaterialDepthTable)
{
	const uint RelativeMaterialIndex = GetRelativeMaterialIndex(InCluster, InTriIndex);
	const uint MaterialDepthId = RemapMaterialIndexToId(InPrimitiveIndex, RelativeMaterialIndex, InMaterialDepthTable);
	return MaterialDepthId;
}

uint GetMaterialHitProxyId(
	FCluster InCluster,
	uint InPrimitiveIndex,
	uint InTriIndex,
	ByteAddressBuffer InMaterialHitProxyTable)
{
	const uint RelativeMaterialIndex = GetRelativeMaterialIndex(InCluster, InTriIndex);
	const uint MaterialHitProxyId = RemapMaterialIndexToId(InPrimitiveIndex, RelativeMaterialIndex, InMaterialHitProxyTable);
	return MaterialHitProxyId;
}

uint GetMaterialBucketIdFromDepth(float Depth)
{
	return (uint)(Depth * MAX_STATE_BUCKET_ID);
}

FNaniteAttributeData GetAttributeData(
	FCluster Cluster,
	uint3 TriIndices,
	float3 PointLocal0,
	float3 PointLocal1,
	float3 PointLocal2,
	FBarycentrics Barycentrics,
	FInstanceSceneData InstanceData,
	uint NumTexCoordInterpolators
)
{
	FNaniteAttributeData AttributeData = (FNaniteAttributeData)0;

	// Unpack and interpolate attributes
	uint DecodeInfoOffset = Cluster.PageBaseAddress + Cluster.DecodeInfoOffset;
	uint AttributeDataOffset = Cluster.PageBaseAddress + Cluster.AttributeOffset;

	// Unpack normal
#if USE_UNCOMPRESSED_VERTEX_DATA
	uint3 ReadOffset = AttributeDataOffset + TriIndices * Cluster.BitsPerAttribute / 8;
	float3 TangentZ0 = asfloat(ClusterPageData.Load3(ReadOffset.x));
	float3 TangentZ1 = asfloat(ClusterPageData.Load3(ReadOffset.y));
	float3 TangentZ2 = asfloat(ClusterPageData.Load3(ReadOffset.z));
	ReadOffset += 12;
#else
	const uint MaxAttributeBits = CalculateMaxAttributeBits(NumTexCoordInterpolators);

	FBitStreamReaderState AttributeStream0 = BitStreamReader_Create_Aligned(ClusterPageData, AttributeDataOffset, TriIndices.x * Cluster.BitsPerAttribute, MaxAttributeBits);
	FBitStreamReaderState AttributeStream1 = BitStreamReader_Create_Aligned(ClusterPageData, AttributeDataOffset, TriIndices.y * Cluster.BitsPerAttribute, MaxAttributeBits);
	FBitStreamReaderState AttributeStream2 = BitStreamReader_Create_Aligned(ClusterPageData, AttributeDataOffset, TriIndices.z * Cluster.BitsPerAttribute, MaxAttributeBits);

	uint NormalBits0 = BitStreamReader_Read(AttributeStream0, 2 * NORMAL_QUANTIZATION_BITS, 2 * NORMAL_QUANTIZATION_BITS);
	uint NormalBits1 = BitStreamReader_Read(AttributeStream1, 2 * NORMAL_QUANTIZATION_BITS, 2 * NORMAL_QUANTIZATION_BITS);
	uint NormalBits2 = BitStreamReader_Read(AttributeStream2, 2 * NORMAL_QUANTIZATION_BITS, 2 * NORMAL_QUANTIZATION_BITS);

	float3 TangentZ0 = UnpackNormal(NormalBits0, NORMAL_QUANTIZATION_BITS);
	float3 TangentZ1 = UnpackNormal(NormalBits1, NORMAL_QUANTIZATION_BITS);
	float3 TangentZ2 = UnpackNormal(NormalBits2, NORMAL_QUANTIZATION_BITS);
#endif

	float3 TangentZ = normalize(Barycentrics.UVW.x * TangentZ0 + Barycentrics.UVW.y * TangentZ1 + Barycentrics.UVW.z * TangentZ2);

	// Decode vertex color
	// This needs to happen even if INTERPOLATE_VERTEX_COLOR is not defined as the data might be there regardless of what the shader needs.
	// When INTERPOLATE_VERTEX_COLOR is not defined, the results are not used and the code mostly disappears.
	AttributeData.UnMirrored = 1.0f;

#if USE_UNCOMPRESSED_VERTEX_DATA
	uint4 Color0 = UnpackToUint4(ClusterPageData.Load(ReadOffset.x), 8);
	uint4 Color1 = UnpackToUint4(ClusterPageData.Load(ReadOffset.y), 8);
	uint4 Color2 = UnpackToUint4(ClusterPageData.Load(ReadOffset.z), 8);
	ReadOffset += 4;
	AttributeData.VertexColor = (Barycentrics.UVW.x * float4(Color0) + Barycentrics.UVW.y * float4(Color1) + Barycentrics.UVW.z * float4(Color2)) * (1.0f / 255.0f);
#else
	uint4 NumComponentBits = UnpackToUint4(Cluster.ColorBits, 4);
	uint4 ColorDelta0 = BitStreamReader_Read4(AttributeStream0, NumComponentBits, MAX_COLOR_QUANTIZATION_BITS);
	uint4 ColorDelta1 = BitStreamReader_Read4(AttributeStream1, NumComponentBits, MAX_COLOR_QUANTIZATION_BITS);
	uint4 ColorDelta2 = BitStreamReader_Read4(AttributeStream2, NumComponentBits, MAX_COLOR_QUANTIZATION_BITS);

	AttributeData.VertexColor = float4(1.0f, 1.0f, 1.0f, 1.0f);
	AttributeData.VertexColor_DDX = 0.0f;
	AttributeData.VertexColor_DDY = 0.0f;
	if (Cluster.ColorMode != VERTEX_COLOR_MODE_WHITE)
	{
		float4 ColorMin = float4(UnpackByte0(Cluster.ColorMin), UnpackByte1(Cluster.ColorMin), UnpackByte2(Cluster.ColorMin), UnpackByte3(Cluster.ColorMin));
		if (Cluster.ColorMode == VERTEX_COLOR_MODE_VARIABLE)
		{
			AttributeData.VertexColor = (ColorMin + Barycentrics.UVW.x * float4(ColorDelta0) + Barycentrics.UVW.y * float4(ColorDelta1) + Barycentrics.UVW.z * float4(ColorDelta2)) * (1.0f / 255.0f);
			AttributeData.VertexColor_DDX = (Barycentrics.UVW_dx.x * float4(ColorDelta0) + Barycentrics.UVW_dx.y * float4(ColorDelta1) + Barycentrics.UVW_dx.z * float4(ColorDelta2)) * (1.0f / 255.0f);
			AttributeData.VertexColor_DDY = (Barycentrics.UVW_dy.x * float4(ColorDelta0) + Barycentrics.UVW_dy.y * float4(ColorDelta1) + Barycentrics.UVW_dy.z * float4(ColorDelta2)) * (1.0f / 255.0f);
		}
		else // (Cluster.ColorMode == VERTEX_COLOR_MODE_CONSTANT)
		{
			AttributeData.VertexColor = ColorMin * (1.0f / 255.0f);
		}
	}
#endif

	// Protect against case where Nanite max UV count is lower than what the material may define.
	if (NumTexCoordInterpolators > 0)
	{
		UNROLL
		for (uint TexCoordIndex = 0; TexCoordIndex < MAX_NANITE_UVS; ++TexCoordIndex)
		{
			// Make sure we're within our interpolator range
			if (TexCoordIndex < NumTexCoordInterpolators)
			{
			#if USE_UNCOMPRESSED_VERTEX_DATA
				float2 TexCoord0 = asfloat(ClusterPageData.Load2(ReadOffset.x));
				float2 TexCoord1 = asfloat(ClusterPageData.Load2(ReadOffset.y));
				float2 TexCoord2 = asfloat(ClusterPageData.Load2(ReadOffset.z));
				ReadOffset += 8;
			#else
				uint2 UVPrec = uint2(BitFieldExtractU32(Cluster.UV_Prec, 4, TexCoordIndex * 8), BitFieldExtractU32(Cluster.UV_Prec, 4, TexCoordIndex * 8 + 4));

				uint2 Bits0_UV = BitStreamReader_Read2(AttributeStream0, UVPrec, MAX_TEXCOORD_QUANTIZATION_BITS);
				uint2 Bits1_UV = BitStreamReader_Read2(AttributeStream1, UVPrec, MAX_TEXCOORD_QUANTIZATION_BITS);
				uint2 Bits2_UV = BitStreamReader_Read2(AttributeStream2, UVPrec, MAX_TEXCOORD_QUANTIZATION_BITS);
			
				FUVRange UVRange = GetUVRange(ClusterPageData, DecodeInfoOffset, TexCoordIndex);
				float2 TexCoord0 = UnpackTexCoord(Bits0_UV, UVRange);
				float2 TexCoord1 = UnpackTexCoord(Bits1_UV, UVRange);
				float2 TexCoord2 = UnpackTexCoord(Bits2_UV, UVRange);
			#endif

				float2 TexCoord10 = TexCoord1 - TexCoord0;
				float2 TexCoord20 = TexCoord2 - TexCoord0;

				float2 TexCoord = TexCoord0 + Barycentrics.UVW.y * TexCoord10 + Barycentrics.UVW.z * TexCoord20;
				AttributeData.TexCoords[TexCoordIndex] = TexCoord;
				AttributeData.TexCoords_DDX[TexCoordIndex] = Barycentrics.UVW_dx.y * TexCoord10 + Barycentrics.UVW_dx.z * TexCoord20;
				AttributeData.TexCoords_DDY[TexCoordIndex] = Barycentrics.UVW_dy.y * TexCoord10 + Barycentrics.UVW_dy.z * TexCoord20;

				// Generate tangent frame for UV0
				if (TexCoordIndex == 0)
				{
					// Implicit tangent space
					// Based on Christian Schlüler's derivation: http://www.thetenthplanet.de/archives/1180
					// The technique derives a tangent space from the interpolated normal and (position,uv) deltas in two not necessarily orthogonal directions.
					// The described technique uses screen space derivatives as a way to obtain these direction deltas in a pixel shader,
					// but as we have the triangle vertices explicitly available using the local space corner deltas directly is faster and more convenient.

					float3 PointLocal10 = PointLocal1 - PointLocal0;
					float3 PointLocal20 = PointLocal2 - PointLocal0;

					bool TangentXValid = abs(TexCoord10.x) + abs(TexCoord20.x) > 1e-6;

					float3 TangentX;
					float3 TangentY;
					if (TangentXValid)
					{
						float3 Perp2 = cross(TangentZ, PointLocal20);
						float3 Perp1 = cross(PointLocal10, TangentZ);
						float3 TangentU = Perp2 * TexCoord10.x + Perp1 * TexCoord20.x;
						float3 TangentV = Perp2 * TexCoord10.y + Perp1 * TexCoord20.y;

						TangentX = normalize(TangentU);
						TangentY = cross(TangentZ, TangentX);

						AttributeData.UnMirrored = dot(TangentV, TangentY) < 0.0f ? -1.0f : 1.0f;
						TangentY *= AttributeData.UnMirrored;
					}
					else
					{
						const float Sign = TangentZ.z >= 0 ? 1 : -1;
						const float a = -rcp( Sign + TangentZ.z );
						const float b = TangentZ.x * TangentZ.y * a;
	
						TangentX = float3(1 + Sign * a * Pow2(TangentZ.x), Sign * b, -Sign * TangentZ.x);
						TangentY = float3(b,  Sign + a * Pow2(TangentZ.y), -TangentZ.y);

						AttributeData.UnMirrored = 1;
					}

					float3x3 TangentToLocal = float3x3(TangentX, TangentY, TangentZ);

					// Should be Pow2(InvScale) but that requires renormalization
					float3x3 LocalToWorld = (float3x3)InstanceData.LocalToWorld;
					float3 InvScale = InstanceData.InvNonUniformScaleAndDeterminantSign.xyz;
					LocalToWorld[0] *= InvScale.x;
					LocalToWorld[1] *= InvScale.y;
					LocalToWorld[2] *= InvScale.z;
					AttributeData.TangentToWorld = mul(TangentToLocal, LocalToWorld);
				}
			}
		}
	}
	else
	{
		// No texture coordinates, so there is no valid tangent frame.
		// TangentToWorld.Z is still being used, so we still have to calculate it.

		// Should be Pow2(InvScale) but that requires renormalization
		half3 InvScale = InstanceData.InvNonUniformScaleAndDeterminantSign.xyz;
		AttributeData.TangentToWorld = float3x3(float3(0,0,0), float3(0,0,0), mul(TangentZ * InvScale.z, (float3x3)InstanceData.LocalToWorld));
	}

	return AttributeData;
}