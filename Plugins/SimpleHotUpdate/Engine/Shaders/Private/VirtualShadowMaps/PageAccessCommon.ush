// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	PageAccessCommon.ush:
=============================================================================*/
#pragma once

#include "../Common.ush"

#ifndef HAS_CACHE_DATA
#define HAS_CACHE_DATA 0
#endif //HAS_CACHE_DATA

// States of a physical page
// Allocated but not cleared
#define VSM_PHYSICAL_PAGE_STATE_INVALID 0
// Cleared
#define VSM_PHYSICAL_PAGE_STATE_CLEARED 1
// Mapped (in page tables) during a call to render (not tracking whether any geo was drawn into the page)
#define VSM_PHYSICAL_PAGE_STATE_RENDERED 2


#if ENABLE_NON_NANITE_VSM
// GPUCULL_TODO: This is probably ok to just leave on.
// Marks pages that are not cached (bit 0)
#define VSM_INVALID_FLAG (1)
// Marks pages that are allocated (bit 1)
#define VSM_ALLOCATED_FLAG (2)
// Super pages are of size 2^SP-Level up to VSM_NUM_SUPER_PAGE_LEVELS
#define VSM_NUM_SUPER_PAGE_LEVELS (3U)
#define VSM_NUM_SUPER_START_BIT (1U)
// Mask inclusive of super pages and the allocated flag, Bits [1,1+VSM_NUM_SUPER_PAGE_LEVELS+1]
#define VSM_SUPER_PAGE_MASK (((1U << (VSM_NUM_SUPER_PAGE_LEVELS + 1U)) - 1U) << 1U)
#else //!ENABLE_NON_NANITE_VSM
// Used in the PageFlags
// Marks pages that are allocated
#define VSM_ALLOCATED_FLAG (1)
// Marks pages that are not cached
#define VSM_INVALID_FLAG (2)
#endif // ENABLE_NON_NANITE_VSM

// GPUCULL_TODO: These 10 bits don't match Nanite and we may run out what with mip-levels and all!
#define VSM_PACKED_PAGE_INFO_VIEW_ID_BITS (10U)
#define VSM_PACKED_PAGE_INFO_SUPER_PAGE_LEVEL_BITS (2U)

struct FPageInfo
{
	uint2 VirtualPage;
	uint ViewId;
	uint SuperPageLevel;
};

uint CalcLog2LevelDimsPages(uint Level)
{
	return VSM_LOG2_LEVEL0_DIM_PAGES_XY - Level;	// log2( VSM_LEVEL0_DIM_PAGES_XY >> Level )
}

uint CalcLevelDimsPages(uint Level)
{
	return 1u << CalcLog2LevelDimsPages( Level );
}

uint CalcLevelDimsTexels(uint Level)
{
	return uint(VSM_VIRTUAL_MAX_RESOLUTION_XY) >> Level;
}

uint CalcLevelOffsets(uint Level)
{
	// VSM_LEVEL0_DIM_PAGES_XY is a power of two, so the footprint of each mip level MipSize_i=(VSM_LEVEL0_DIM_PAGES_XY>>i)^2 is also a power of two.
	// The binary representation of a mip size is just a single bit: 1 << log2(MipSize_i) = (1 << (2 * (VSM_LOG2_LEVEL0_DIM_PAGES_XY - i))).
	
	// To calculate the offset we need to calculate a sum of consecutive mip sizes, which is equivalent to producing a bit pattern with one bit per level starting out at 
	// bitposition 2*VSM_LOG2_LEVEL0_DIM_PAGES_XY and going down by 2 for every level.
	// E.g. VSM_LEVEL0_DIM_PAGES_XY=3
	//   Level 0: 0000000
	//   Level 1: 1000000
	//   Level 2: 1010000
	//   Level 3: 1010100
	//   Level 4: 1010101

	// To quickly produce a variable number of bits we just select a range of bits from the alternating bit sequence 0x55=0b01010101.
	uint NumBits = Level << 1;
	uint StartBit = (2 * VSM_LOG2_LEVEL0_DIM_PAGES_XY + 2) - NumBits;
#if COMPILER_SUPPORTS_BITFIELD_INTRINSICS
	uint Mask = BitFieldMaskU32(NumBits, StartBit);
#else
	uint Mask = ((1u << NumBits) - 1u) << StartBit;
#endif

	return 0x55555555u & Mask;
}

uint CalcHPageFlagLevelOffsets(uint Level)
{
	return VirtualShadowMap.HPageFlagLevelOffsets[Level];
}

/**
 * Compute the offset for a mip level page table given a shadow map ID and a level.
 */
uint CalcPageTableLevelOffset(uint ShadowMapID, uint Level)
{
	return ShadowMapID * VSM_PAGE_TABLE_SIZE + CalcLevelOffsets(Level);
}

/**
 * Compute the offset for page within a level page table given a level and PageAddress.
 */
uint CalcPageOffsetInLevel(uint Level, uint2 PageAddress)
{
	// return PageAddress.x + PageAddress.y * LevelDimsPages[Level];
	return PageAddress.x + ( PageAddress.y << CalcLog2LevelDimsPages(Level) );
}

uint CalcPageOffset(uint ShadowMapID, uint Level, uint2 PageAddress)
{
	return CalcPageTableLevelOffset(ShadowMapID, Level) + CalcPageOffsetInLevel(Level, PageAddress);
}

// Linearlize a physical page address to a linear offset
uint PhysPageAddressToIndex(uint2 PhysicalPageAddress)
{
	return (PhysicalPageAddress.y << VirtualShadowMap.PhysicalPageRowShift) + PhysicalPageAddress.x;
}

// Current page table format:
// NOTE: Some redundancy in flags and encoding, but we have spare bits for now
//   [0:9] PageIndex.x
//   [10:19] PageIndex.y
//   [20:25] LODOffset
//   [26:30] (currently unused)
//   [31] bAnyLODValid
struct FShadowPhysicalPage
{
	uint2 PageIndex;		// Physical page index X, Y
	uint LODOffset;			// 0 if page is mapped at this mip/clipmap level; 1 if mapped at next courser level, etc. [0..64)
	bool bAnyLODValid;		// Valid physical page mapped at some LOD level
	bool bThisLODValid;		// Valid page mapped at this specific level (equivalent to bAnyMipValid && LODOffset == 0)
};

#define VSM_PHYSICAL_PAGE_ANY_MIP_VALID_FLAG 0x8000000
#define VSM_PHYSICAL_PAGE_INVALID 0x00000000

// TODO: Remove this, but need to update cache metadata
#define VSM_INVALID_PHYSICAL_PAGE_ADDRESS 65535

uint ShadowEncodePageTable(uint2 PageIndex)
{
	return VSM_PHYSICAL_PAGE_ANY_MIP_VALID_FLAG | (PageIndex.y << 10) | (PageIndex.x);
}
uint ShadowEncodePageTable(uint2 PageIndex, uint LODOffset)
{
	return VSM_PHYSICAL_PAGE_ANY_MIP_VALID_FLAG | (LODOffset << 20) | (PageIndex.y << 10) | (PageIndex.x);
}

FShadowPhysicalPage ShadowDecodePageTable(uint Value)
{
	FShadowPhysicalPage Result;
	Result.PageIndex = uint2(Value & 0x3FF, (Value >> 10) & 0x3FF);
	Result.LODOffset = (Value >> 20) & 0x3F;
	Result.bAnyLODValid = (Value & VSM_PHYSICAL_PAGE_ANY_MIP_VALID_FLAG) != 0;
	Result.bThisLODValid = Result.bAnyLODValid && Result.LODOffset == 0;
	return Result;
}

FShadowPhysicalPage ShadowGetPhysicalPage(uint PageOffset)
{
	return ShadowDecodePageTable(VirtualShadowMap.PageTable[PageOffset]);
}

bool VirtualToPhysicalTexel(uint ShadowMapID, uint Level, uint2 VirtualTexelAddress, inout uint2 PhysicalTexelAddress)
{
	uint VPageX = VirtualTexelAddress.x >> VSM_LOG2_PAGE_SIZE;
	uint VPageY = VirtualTexelAddress.y >> VSM_LOG2_PAGE_SIZE;

	FShadowPhysicalPage PhysicalPageEntry = ShadowGetPhysicalPage(CalcPageOffset(ShadowMapID, Level, uint2(VPageX, VPageY)));
	PhysicalTexelAddress = PhysicalPageEntry.PageIndex * VSM_PAGE_SIZE + (VirtualTexelAddress & VSM_PAGE_SIZE_MASK);
	return (PhysicalPageEntry.bThisLODValid);
}

struct FShadowPageTranslationResult
{
	bool bValid;
	uint LODOffset;
	uint2 VirtualTexelAddress;
	float2 VirtualTexelAddressFloat;
	uint2 PhysicalTexelAddress;
};

// Finds the best-resolution mapped page at the given UV
FShadowPageTranslationResult ShadowVirtualToPhysicalUV(uint VirtualShadowMapID, float2 ShadowMapUV)
{
	uint2 vPage = uint2( ShadowMapUV * VSM_LEVEL0_DIM_PAGES_XY );

	FShadowPhysicalPage PhysicalPageEntry = ShadowGetPhysicalPage( VirtualShadowMapID * VSM_PAGE_TABLE_SIZE + vPage.x + vPage.y * VSM_LEVEL0_DIM_PAGES_XY );

	FShadowPageTranslationResult Result;
	Result.bValid = PhysicalPageEntry.bAnyLODValid;
	Result.LODOffset = PhysicalPageEntry.LODOffset;
	// TODO: Can optimize this slightly based on relative offset
	Result.VirtualTexelAddressFloat = ShadowMapUV * float(CalcLevelDimsTexels(Result.LODOffset));
	Result.VirtualTexelAddress = uint2(Result.VirtualTexelAddressFloat);
	Result.PhysicalTexelAddress = PhysicalPageEntry.PageIndex * VSM_PAGE_SIZE + (Result.VirtualTexelAddress & VSM_PAGE_SIZE_MASK);

	return Result;
}
