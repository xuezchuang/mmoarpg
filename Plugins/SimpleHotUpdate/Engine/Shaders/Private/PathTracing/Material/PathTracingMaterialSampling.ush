// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================================
PathTracingMaterialSampling.usf: Material sampling functions
===============================================================================================*/

#pragma once

#include "PathTracingMaterialCommon.ush"
#include "PathTracingFresnel.ush"
#include "PathTracingLambert.ush"
#include "PathTracingRadianceProbe.ush"
#include "PathTracingGlossy.ush"
#include "PathTracingSpecularReflection.ush"
#include "PathTracingSpecularTransmission.ush"
#include "PathTracingSolidGlass.ush"
#include "PathTracingThinGlass.ush"
#include "PathTracingDefaultLit.ush"
#include "PathTracingClearCoat.ush"
#include "PathTracingTwoSidedFoliage.ush"
#include "PathTracingCloth.ush"

#ifndef FORCE_ALL_MATERIALS_DIFFUSE
	#define FORCE_ALL_MATERIALS_DIFFUSE 0
#endif

bool IsNeeValidMaterial(FMaterialClosestHitPayload Payload)
{
	// Checks done in the same order as other sampling and evaluation functions to ensure consistency
	
#if FORCE_ALL_MATERIALS_DIFFUSE
	return true;
#else

	if (Payload.BlendingMode == RAY_TRACING_BLEND_MODE_MODULATE ||
		Payload.BlendingMode == RAY_TRACING_BLEND_MODE_ALPHA_HOLDOUT)
	{
		return false;
	}

	switch (Payload.ShadingModelID)
	{
		case SHADINGMODELID_UNLIT:
			return false;
		case SHADINGMODELID_DEFAULT_LIT:		
		case SHADINGMODELID_CLEAR_COAT:			
		case SHADINGMODELID_TWOSIDED_FOLIAGE:	
		case SHADINGMODELID_THIN_TRANSLUCENT:
		case SHADINGMODELID_CLOTH:
		default:
			return true;
	}
#endif
}

float3 GetMaterialTransparency(FMaterialClosestHitPayload Payload, float3 RayDirection)
{
	if (Payload.ShadingModelID == SHADINGMODELID_THIN_TRANSLUCENT)
	{
		if (Payload.Ior == 1.0)
		{
			float VoN = dot(RayDirection, Payload.WorldNormal);
			return (1 - Payload.Opacity) * pow(Payload.CustomData.xyz, 1.0 / abs(VoN));
		}
		else
		{
			return 0;
		}
	}
	switch (Payload.BlendingMode)
	{
		case RAY_TRACING_BLEND_MODE_TRANSLUCENT:
			if (Payload.Ior == 1.0)
			{
				// material is not configured with refraction, can use transparency
				return 1 - Payload.Opacity;
			}
			else
			{
				// not using transparency - material will be opaque
				return 0;
			}
		case RAY_TRACING_BLEND_MODE_ADDITIVE:
			return 1;
		case RAY_TRACING_BLEND_MODE_MODULATE:
			return Payload.Radiance;
		case RAY_TRACING_BLEND_MODE_ALPHA_COMPOSITE:
			return 1 - Payload.Opacity;
		case RAY_TRACING_BLEND_MODE_ALPHA_HOLDOUT:
			return 1;
		default: 
			return 0;
	}
}

float3 EstimateMaterialAlbedo(FMaterialClosestHitPayload Payload)
{
	float BrdfWeight = 1;
	bool HasRefraction = false;
	switch (Payload.BlendingMode)
	{
		case RAY_TRACING_BLEND_MODE_TRANSLUCENT:
			if (Payload.Ior == 1.0)
			{
				// material is not configured with refraction, can use transparency
				// NOTE: the albedo when considering refraction is handled below
				BrdfWeight = Payload.Opacity;
			}
			else
			{
				HasRefraction = true;
			}
			break;
		case RAY_TRACING_BLEND_MODE_ADDITIVE:
			BrdfWeight = Payload.Opacity;
			break;
		case RAY_TRACING_BLEND_MODE_MODULATE:
		case RAY_TRACING_BLEND_MODE_ALPHA_HOLDOUT:
			// In these modes, the light does not interact with the material at all, only passes through
			return 0;
		default:
			break;
	}

	float3 Albedo = 0;
	switch (Payload.ShadingModelID)
	{
		case SHADINGMODELID_UNLIT:
			// this object does not scatter light
			return 0;
		case SHADINGMODELID_TWOSIDED_FOLIAGE:
			Albedo = BrdfWeight * (Payload.DiffuseColor + Payload.SpecularColor + GetSubsurfaceColor(Payload));
			break;
		case SHADINGMODELID_DEFAULT_LIT:
		case SHADINGMODELID_CLEAR_COAT:
			// FIXME: could make this more accurate by estimating the directional albedo
			Albedo = BrdfWeight * (Payload.DiffuseColor + Payload.SpecularColor);
		case SHADINGMODELID_CLOTH:
			Albedo = BrdfWeight * (Payload.DiffuseColor + lerp(Payload.SpecularColor, Payload.CustomData.xyz, Payload.CustomData.w));
			break;
		default:
			Albedo = BrdfWeight * Payload.BaseColor;
			break;
	}
	if (HasRefraction)
	{
		// glass is currently perfectly clear - so has unit albedo
		// TODO: estimate some kind of albedo for thin-translucent case since that one uses a color?
		float3 White = 1;
		Albedo = lerp(White, Albedo, Payload.Opacity);
	}
	return Albedo;
}

void AdjustPathAndMaterialRoughness(inout FMaterialClosestHitPayload Payload, inout float PathRoughness)
{
	// boost material roughness according to what we've seen so far
	float CoatRoughness = Payload.Roughness;
	switch (Payload.ShadingModelID)
	{
		case SHADINGMODELID_UNLIT:
			// this object does not scatter light
			return;
		case SHADINGMODELID_CLEAR_COAT:
			// clamp coat roughness
			CoatRoughness = Payload.CustomData.y = max(GetClearCoatRoughness(Payload), PathRoughness);
			// fallthrough
		case SHADINGMODELID_TWOSIDED_FOLIAGE:
		case SHADINGMODELID_DEFAULT_LIT:
		case SHADINGMODELID_THIN_TRANSLUCENT:
		case SHADINGMODELID_CLOTH:
			Payload.Roughness = max(Payload.Roughness, PathRoughness);
			break;
		default:
			// fallback is diffuse
			Payload.Roughness = 1.0;
			break;
	}
	// now set the path roughness going forward
	const float GlassPercent = (Payload.BlendingMode == RAY_TRACING_BLEND_MODE_TRANSLUCENT && Payload.Ior != 1.0) ? 1 - Payload.Opacity : 0.0;
	PathRoughness = lerp(1.0 /* diffuse lobe */, max(CoatRoughness, Payload.Roughness), Payload.Metallic);
	PathRoughness = lerp(PathRoughness, Payload.Roughness, GlassPercent);
}

void SampleMaterial(
	float3 RayDirection,
	FMaterialClosestHitPayload Payload,
	float4 RandSample,
	bool bForceRadianceProbe,
	out float3 OutDirection,
	out float3 OutWeight,
	out float OutPdf,
	out float OutPositionBiasSign)
{
	OutPositionBiasSign = 1;
	
	if (bForceRadianceProbe)
	{
		RadianceProbe_SampleMaterial(Payload, RandSample, OutDirection, OutWeight, OutPdf);
		return;
	}
	
#if FORCE_ALL_MATERIALS_DIFFUSE
	{
		Lambert_SampleMaterial(Payload, RandSample, OutDirection, OutWeight, OutPdf);
	}
#else

	if (Payload.BlendingMode == RAY_TRACING_BLEND_MODE_MODULATE ||
		Payload.BlendingMode == RAY_TRACING_BLEND_MODE_ALPHA_HOLDOUT)
	{
		// transparency only, nothing to sample
		OutDirection = 0;
		OutWeight = 0;
		OutPdf = 0;
		return;
	}

	// Decide the overall weight of the BRDF portion vs. the translucent portion
	// Note that the translucent portion could be refraction, transparency or SSS
	float BrdfWeight = 1;
	float TransWeight = 0;
	float BrdfProb = 1;
	switch (Payload.BlendingMode)
	{
		case RAY_TRACING_BLEND_MODE_TRANSLUCENT:
			if (Payload.Ior == 1.0)
			{
				// scale down BRDF contribution, but don't pick any indirect ray because its already accounted for by transparency handling
				BrdfWeight = Payload.Opacity;
			}
			else
			{
				// randomly choose between brdf and glass
				BrdfWeight = 1;
				TransWeight = 1;
				BrdfProb = Payload.Opacity;
			}
			break;
		case RAY_TRACING_BLEND_MODE_ADDITIVE:
			BrdfWeight = Payload.Opacity;
			break;
		default:
			// opaque or one of the modes handled above
			break;
	}

	if (RandSample.x < BrdfProb)
	{
		// we randomly decided to sample the brdf portion of the material
		RandSample.x /= BrdfProb;
	}
	else
	{
		// we randomly decided to sample the translucent portion
		RandSample.x = (RandSample.x - BrdfProb) / (1 - BrdfProb);

		// only case that should reach this point is the refraction model (which can be thin or solid)
		if (Payload.ShadingModelID == SHADINGMODELID_THIN_TRANSLUCENT)
		{
			RoughThinGlass_SampleMaterial(RayDirection, Payload, RandSample, OutDirection, OutWeight, OutPdf, OutPositionBiasSign);
		}
		else if (Payload.Roughness == 0)
		{
			SpecularRefraction_SampleMaterial(RayDirection, Payload, RandSample, OutDirection, OutWeight, OutPdf, OutPositionBiasSign);
		}
		else
		{
			RoughGlass_SampleMaterial(RayDirection, Payload, RandSample, OutDirection, OutWeight, OutPdf, OutPositionBiasSign);
		}
		OutWeight *= TransWeight;
		OutPdf *= 1 - BrdfProb;
		return;
	}

	switch (Payload.ShadingModelID)
	{
		case SHADINGMODELID_UNLIT:
			// Nothing to do, material does not scatter light
			OutDirection = 0;
			OutWeight = 0;
			OutPdf = 0;
			return;
		case SHADINGMODELID_DEFAULT_LIT:
			DefaultLit_SampleMaterial(RayDirection, Payload, RandSample, OutDirection, OutWeight, OutPdf);
			break;
		case SHADINGMODELID_CLOTH:
			Cloth_SampleMaterial(RayDirection, Payload, RandSample, OutDirection, OutWeight, OutPdf);
			break;
		case SHADINGMODELID_CLEAR_COAT:
			ClearCoat_SampleMaterial(RayDirection, Payload, RandSample, OutDirection, OutWeight, OutPdf);
			break;
		case SHADINGMODELID_TWOSIDED_FOLIAGE:
			TwoSidedFoliage_SampleMaterial(RayDirection, Payload, RandSample, OutDirection, OutWeight, OutPdf, OutPositionBiasSign);
			break;
		default:
			Lambert_SampleMaterial(Payload, RandSample, OutDirection, OutWeight, OutPdf);
			break;
	}

	// final adjustment to weight / prob based on the stochastic decision for translucency earlier
	OutWeight *= BrdfWeight;
	OutPdf *= BrdfProb;
#endif
}

void EvalMaterial(
	float3 IncomingDirection,
	float3 OutgoingDirection,
	FMaterialClosestHitPayload Payload,
	bool bForceRadianceProbe,
	out float3 OutWeight,
	out float OutPdf
)
{
	if (bForceRadianceProbe)
	{
		RadianceProbe_EvalMaterial(OutgoingDirection, Payload, OutWeight, OutPdf);
		return;
	}
	
#if FORCE_ALL_MATERIALS_DIFFUSE
	{
		Lambert_EvalMaterial(OutgoingDirection, Payload, OutWeight, OutPdf);
	}
#else

	if (Payload.BlendingMode == RAY_TRACING_BLEND_MODE_MODULATE ||
		Payload.BlendingMode == RAY_TRACING_BLEND_MODE_ALPHA_HOLDOUT)
	{
		OutWeight = 0;
		OutPdf = 0;
		return;
	}

	// Decide the overall weight of the BRDF portion vs. the translucent portion
	// Note that the translucent portion could be refraction, transparency or SSS
	float BrdfWeight = 1;
	float TransWeight = 0;
	float BrdfProb = 1;
	switch (Payload.BlendingMode)
	{
		case RAY_TRACING_BLEND_MODE_TRANSLUCENT:
			// brdf:   Opacity
			// glass:  1.0 - Opacity
			if (Payload.Ior == 1.0)
			{
				// handled by native transpaarency, just weight down the brdf contrib
				BrdfWeight = Payload.Opacity;
			}
			else
			{
				// brdf or glass
				BrdfWeight = 1;
				TransWeight = 1;
				BrdfProb = Payload.Opacity;
			}
			break;
		case RAY_TRACING_BLEND_MODE_ADDITIVE:
			// brdf:   Opacity
			BrdfWeight = Payload.Opacity;
			break;
		default:
			// opaque or one of the modes handled above
			break;
	}

	// NOTE: the translucent portions are all singular -- so we can ignore them in the eval method for now as they have Pdf=+inf for a single direction only

	switch (Payload.ShadingModelID)
	{
		case SHADINGMODELID_UNLIT:
			OutWeight = 0.0;
			OutPdf = 0.0;
			break;
		case SHADINGMODELID_DEFAULT_LIT:
			DefaultLit_EvalMaterial(IncomingDirection, OutgoingDirection, Payload, OutWeight, OutPdf);
			break;
		case SHADINGMODELID_CLOTH:
			Cloth_EvalMaterial(IncomingDirection, OutgoingDirection, Payload, OutWeight, OutPdf);
			break;
		case SHADINGMODELID_CLEAR_COAT:
			ClearCoat_EvalMaterial(IncomingDirection, OutgoingDirection, Payload, OutWeight, OutPdf);
			break;
		case SHADINGMODELID_TWOSIDED_FOLIAGE:
			TwoSidedFoliage_EvalMaterial(IncomingDirection, OutgoingDirection, Payload, OutWeight, OutPdf);
			break;
		default:
			Lambert_EvalMaterial(OutgoingDirection, Payload, OutWeight, OutPdf);
			break;
	}

	// final adjustment to weight / prob for translucency
	OutWeight *= BrdfWeight;
	OutPdf *= BrdfProb;

	if (BrdfProb < 1.0)
	{
		// refraction model (only evaluate for rough case as singular can't be evaluated)
		if (Payload.Roughness != 0)
		{
			float3 GlassWeight = 0;
			float GlassPdf = 0;
			if (Payload.ShadingModelID == SHADINGMODELID_THIN_TRANSLUCENT)
			{
				// just a thin slab (reflection-like lobe on both sides)
				RoughThinGlass_EvalMaterial(IncomingDirection, OutgoingDirection, Payload, GlassWeight, GlassPdf);
			}
			else
			{
				// real solid glass, reflection and refraction
				RoughGlass_EvalMaterial(IncomingDirection, OutgoingDirection, Payload, GlassWeight, GlassPdf);
			}
			

			AddLobeWithMIS(OutWeight, OutPdf, GlassWeight, GlassPdf, 1.0 - BrdfProb);
		}
	}
#endif
}
