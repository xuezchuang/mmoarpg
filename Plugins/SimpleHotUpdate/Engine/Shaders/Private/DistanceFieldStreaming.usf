// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	DistanceFieldStreaming.usf
=============================================================================*/

#include "Common.ush"
#include "DistanceFieldLightingShared.ush"

RWTexture3D<UNORM float> RWDistanceFieldBrickAtlas;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, THREADGROUP_SIZE)]
void CopyDistanceFieldAtlasCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	RWDistanceFieldBrickAtlas[DispatchThreadId] = DistanceFieldBrickTexture[DispatchThreadId];
}

Buffer<uint4> BrickUploadCoordinates;
Buffer<float> BrickUploadData;
uint StartBrickIndex;
uint NumBrickUploads;
uint BrickSize;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, THREADGROUP_SIZE)]
void ScatterUploadDistanceFieldAtlasCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint BrickOffsetIndex = GroupId.z * THREADGROUP_SIZE / BrickSize;

	if (BrickOffsetIndex < NumBrickUploads)
	{
		uint BrickIndex = StartBrickIndex + BrickOffsetIndex;
		uint3 VoxelCoordinate = DispatchThreadId % BrickSize;
		uint UploadDataReadIndex = BrickIndex * BrickSize * BrickSize * BrickSize + (VoxelCoordinate.z * BrickSize + VoxelCoordinate.y) * BrickSize + VoxelCoordinate.x;
		uint3 BrickAtlasCoordinate = BrickUploadCoordinates[BrickIndex];
		RWDistanceFieldBrickAtlas[BrickAtlasCoordinate * BrickSize + VoxelCoordinate] = BrickUploadData[UploadDataReadIndex];
	}
}

RWStructuredBuffer<uint> RWDistanceFieldAssetWantedNumMips;
RWStructuredBuffer<uint> RWDistanceFieldAssetStreamingRequests;

float3 Mip1WorldCenter;
float3 Mip1WorldExtent;
float3 Mip2WorldCenter;
float3 Mip2WorldExtent;

float ComputeSquaredDistanceBetweenAABBs(float3 CenterA, float3 ExtentA, float3 CenterB, float3 ExtentB)
{
	float3 AxisDistances = max(abs(CenterB - CenterA) - (ExtentA + ExtentB), 0);
	return dot(AxisDistances, AxisDistances);
}

uint DebugForceNumMips;

[numthreads(THREADGROUP_SIZE, 1, 1)]
void ComputeDistanceFieldAssetWantedMipsCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	if (DispatchThreadId.x == 0)
	{
		RWDistanceFieldAssetStreamingRequests[0] = 0;
	}

	uint ObjectIndex = DispatchThreadId.x;

	if (ObjectIndex < NumSceneObjects)
	{
		FDFObjectData DFObjectData = LoadDFObjectData(ObjectIndex);

		uint WantedNumMips = 1;
		if (DebugForceNumMips == 0)
		{
			FDFObjectBounds DFObjectBounds = LoadDFObjectBounds(ObjectIndex);
			float OuterDistanceSq = ComputeSquaredDistanceBetweenAABBs(Mip1WorldCenter, Mip1WorldExtent, DFObjectBounds.Center, DFObjectBounds.BoxExtent);
 
			if (OuterDistanceSq <= 0)
			{
				float InnerDistanceSq = ComputeSquaredDistanceBetweenAABBs(Mip2WorldCenter, Mip2WorldExtent, DFObjectBounds.Center, DFObjectBounds.BoxExtent);
				WantedNumMips = InnerDistanceSq <= 0 ? 3 : 2;
			}
		}
		else
		{
			WantedNumMips = DebugForceNumMips;
		}

		// RWDistanceFieldAssetWantedNumMips is already cleared to 1 so we can skip some memory loads and atomics
		BRANCH
		if (WantedNumMips > 1)
		{
			FDFObjectData DFObjectData = LoadDFObjectData(ObjectIndex);
			InterlockedMax(RWDistanceFieldAssetWantedNumMips[DFObjectData.AssetIndex], WantedNumMips);
		}
	}
}

StructuredBuffer<uint> DistanceFieldAssetWantedNumMips;
uint NumDistanceFieldAssets;
uint MaxNumStreamingRequests;

[numthreads(THREADGROUP_SIZE, 1, 1)]
void GenerateDistanceFieldAssetStreamingRequestsCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint AssetIndex = DispatchThreadId.x;

	if (AssetIndex < NumDistanceFieldAssets)
	{
		uint NumMips = LoadDFAssetData(AssetIndex, 0).NumMips;
		uint WantedNumMips = DistanceFieldAssetWantedNumMips[AssetIndex];

		if (WantedNumMips != 0 && NumMips != 0 && NumMips != WantedNumMips)
		{
			uint StreamingRequestIndex;
			InterlockedAdd(RWDistanceFieldAssetStreamingRequests[0], 1, StreamingRequestIndex);

			if (StreamingRequestIndex < MaxNumStreamingRequests)
			{
				RWDistanceFieldAssetStreamingRequests[1 + StreamingRequestIndex * 2 + 0] = AssetIndex;
				RWDistanceFieldAssetStreamingRequests[1 + StreamingRequestIndex * 2 + 1] = WantedNumMips;
			}
		}
	}
}