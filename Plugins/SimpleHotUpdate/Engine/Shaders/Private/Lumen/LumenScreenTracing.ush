// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenScreenTracing.ush
=============================================================================*/

#pragma once

#include "../Common.ush"
#include "../FastMath.ush"
#include "../SceneTextureParameters.ush"

Texture2D<float> ClosestHZBTexture;
float2 HZBBaseTexelSize;
float4 HZBUVToScreenUVScaleBias;

// HZB mip 0 is half res scene depth. To do accurate traces we need to traverse all the way down to full res scene depth, but this adds an incoherent branch on the inner tracing loop.
#ifndef HZB_TRACE_INCLUDE_FULL_RES_DEPTH
#define HZB_TRACE_INCLUDE_FULL_RES_DEPTH 0
#endif

/**
 * Accurate but slow screen trace by traversing the HZB.
 * RayTranslatedWorldOrigin must be a position on-screen
 * RayWorldDirection must be unit length
 * OutScreenUV gives either the hit screen UV or the screen UV of the furthest unoccluded position along the ray, which can be plugged into ComputeRayHitSqrDistance.  
 * OutScreenUV can sometimes be further than MaxWorldTraceDistance should have allowed.
 */
void TraceScreen(
	float3 RayTranslatedWorldOrigin, 
	float3 RayWorldDirection,
	float MaxWorldTraceDistance,
	float4 HZBUvFactorAndInvFactor,
	float MaxIterations,
	float UncertainTraceRelativeDepthThreshold,
	float NumThicknessStepsToDetermineCertainty,
	inout bool bHit,
	inout bool bUncertain,
	inout float3 OutScreenUV)
{
	float3 RayStartScreenUV;
	{
		float4 RayStartClip = mul(float4(RayTranslatedWorldOrigin, 1.0f), View.TranslatedWorldToClip);
		float3 RayStartScreenPosition = RayStartClip.xyz / max(RayStartClip.w, 1.0f);
		RayStartScreenUV = float3((RayStartScreenPosition.xy * float2(0.5f, -0.5f) + 0.5f) * HZBUvFactorAndInvFactor.xy, RayStartScreenPosition.z);
	}
	
	float3 RayEndScreenUV;
	{
		float3 ViewRayDirection = mul(float4(RayWorldDirection, 0.0), View.TranslatedWorldToView).xyz;
		float SceneDepth = mul(float4(RayTranslatedWorldOrigin, 1.0f), View.TranslatedWorldToView).z;
		// Clamps the ray to end at the Z == 0 plane so the end point will be valid in NDC space for clipping
		float RayEndWorldDistance = ViewRayDirection.z < 0.0 ? min(-0.99f * SceneDepth / ViewRayDirection.z, MaxWorldTraceDistance) : MaxWorldTraceDistance;

		float3 RayWorldEnd = RayTranslatedWorldOrigin + RayWorldDirection * RayEndWorldDistance;
		float4 RayEndClip = mul(float4(RayWorldEnd, 1.0f), View.TranslatedWorldToClip);
		float3 RayEndScreenPosition = RayEndClip.xyz / RayEndClip.w;
		RayEndScreenUV = float3((RayEndScreenPosition.xy * float2(0.5f, -0.5f) + 0.5f) * HZBUvFactorAndInvFactor.xy, RayEndScreenPosition.z);

		float2 ScreenEdgeIntersections = LineBoxIntersect(RayStartScreenUV, RayEndScreenUV, float3(0, 0, 0), float3(HZBUvFactorAndInvFactor.xy, 1));

		// Recalculate end point where it leaves the screen
		RayEndScreenUV = RayStartScreenUV + (RayEndScreenUV - RayStartScreenUV) * ScreenEdgeIntersections.y;
	}

	float BaseMipLevel = HZB_TRACE_INCLUDE_FULL_RES_DEPTH ? -1 : 0;
	float MipLevel = BaseMipLevel;

	// Step out of current tile without hit test to avoid self-intersection
	// This is necessary because HZB mip 0 is the closest of the 2x2 depths, and because HZB is stored in 16 bit fp
	bool bStepOutOfCurrentTile = true;

	if (bStepOutOfCurrentTile)
	{
		float2 HZBTileSize = exp2(MipLevel) * HZBBaseTexelSize;
		float2 BiasedUV = RayStartScreenUV.xy;
		float3 HZBTileMin = float3(floor(BiasedUV.xy / HZBTileSize) * HZBTileSize, 0.0f);
		float3 HZBTileMax = float3(HZBTileMin.xy + HZBTileSize, 1);
		float2 TileIntersections = LineBoxIntersect(RayStartScreenUV, RayEndScreenUV, HZBTileMin, HZBTileMax);

		{
			float3 RayTileHit = RayStartScreenUV + (RayEndScreenUV - RayStartScreenUV) * TileIntersections.y;
			RayStartScreenUV = RayTileHit;
		}
	}

	bHit = false;
	bUncertain = false;

	float RayLength2D = length(RayEndScreenUV.xy - RayStartScreenUV.xy);
	float2 RayDirectionScreenUV = (RayEndScreenUV.xy - RayStartScreenUV.xy) / max(RayLength2D, .0001f);
	float3 RayScreenUV = RayStartScreenUV;
	float NumIterations = 0;
	
	// Stackless HZB traversal
	while (MipLevel >= BaseMipLevel && NumIterations < MaxIterations)
	{
		float2 HZBTileSize = exp2(MipLevel) * HZBBaseTexelSize;
		// RayScreenUV is on a tile boundary due to bStepOutOfCurrentTile
		// Offset the UV along the ray direction so it always quantizes to the next tile
		float2 BiasedUV = RayScreenUV.xy + .01f * RayDirectionScreenUV.xy * HZBTileSize;
		float3 HZBTileMin = float3(floor(BiasedUV / HZBTileSize) * HZBTileSize, 0.0f);
		float3 HZBTileMax = float3(HZBTileMin.xy + HZBTileSize, 1);
		float2 TileIntersections = LineBoxIntersect(RayStartScreenUV, RayEndScreenUV, HZBTileMin, HZBTileMax);
		float3 RayTileHit = RayStartScreenUV + (RayEndScreenUV - RayStartScreenUV) * TileIntersections.y;

		float TileZ;
		float AvoidSelfIntersectionZScale = 1.0f;

#if HZB_TRACE_INCLUDE_FULL_RES_DEPTH
		if (MipLevel < 0)
		{
			TileZ = SceneDepthTexture.SampleLevel(GlobalPointClampedSampler, BiasedUV * HZBUVToScreenUVScaleBias.xy + HZBUVToScreenUVScaleBias.zw, 0).x;
		}
		else
#endif
		{
			TileZ = ClosestHZBTexture.SampleLevel(GlobalPointClampedSampler, BiasedUV, MipLevel).x;
			// Heuristic to avoid incorrect self-intersection because HZB mip 0 is actually the closest of the 2x2 depths, and because HZB is only 16 bit fp
			AvoidSelfIntersectionZScale = lerp(.99f, 1.0f, saturate(TileIntersections.y * 10.0f));
		}

		if (RayTileHit.z > TileZ * AvoidSelfIntersectionZScale)
		{
			RayScreenUV = RayTileHit;
			MipLevel++;

			if (TileIntersections.y == 1.0f)
			{
				// Ray did not intersect HZB tile, no hit
				MipLevel = BaseMipLevel - 1;
			}
		}
		else
		{
			if (abs(MipLevel - BaseMipLevel) < .1f)
			{
				// Snap the hit UV to the center of the texel for the SceneColor lookup
				//@todo - rederive Z
				RayScreenUV = float3(.5f * (HZBTileMin.xy + HZBTileMax.xy), RayTileHit.z);
				bHit = true;
				float IntersectionDepth = ConvertFromDeviceZ(TileZ);
				float RayTileEnterZ = RayStartScreenUV.z + (RayEndScreenUV.z - RayStartScreenUV.z) * TileIntersections.x;
				bUncertain = (ConvertFromDeviceZ(RayTileEnterZ) - IntersectionDepth) / max(IntersectionDepth, .00001f) > UncertainTraceRelativeDepthThreshold;
			}

			MipLevel--;
		}

		NumIterations++;
	}

	// Linear steps to determine feature thickness along the ray, to reject hits behind very thin surfaces (grass / hair / foliage)
	if (bHit && !bUncertain && NumThicknessStepsToDetermineCertainty > 0)
	{
		float ThicknessSearchMipLevel = 0.0f;
		float MipNumTexels = exp2(ThicknessSearchMipLevel);
		float2 HZBTileSize = MipNumTexels * HZBBaseTexelSize;
		float NumSteps = NumThicknessStepsToDetermineCertainty / MipNumTexels;
		float ThicknessSearchEndTime = min(length(RayDirectionScreenUV * HZBTileSize * NumSteps) / length(RayEndScreenUV.xy - RayScreenUV.xy), 1.0f);

		for (float I = 0; I < NumSteps; I++)
		{
			float3 SampleUV = RayScreenUV + (I / NumSteps) * ThicknessSearchEndTime * (RayEndScreenUV - RayScreenUV);

			if (all(SampleUV.xy > 0 && SampleUV.xy < HZBUvFactorAndInvFactor.xy))
			{
				float SampleTileZ = ClosestHZBTexture.SampleLevel(GlobalPointClampedSampler, SampleUV.xy, ThicknessSearchMipLevel).x;

				if (SampleUV.z > SampleTileZ)
				{
					bUncertain = true;
				}
			}
		}
	}

	// Debug - visualize clipped endpoints
	//RayScreenUV = RayEndScreenUV;
	//bHit = bUncertain;

	// Output in GBuffer SceneUV space for xy
	OutScreenUV.xy = RayScreenUV.xy * HZBUVToScreenUVScaleBias.xy + HZBUVToScreenUVScaleBias.zw;
	OutScreenUV.z = RayScreenUV.z;
}