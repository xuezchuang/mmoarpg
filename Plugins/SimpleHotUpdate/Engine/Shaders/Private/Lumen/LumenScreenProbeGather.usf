// Copyright Epic Games, Inc. All Rights Reserved.

#include "../Common.ush"
#include "../DeferredShadingCommon.ush"
#include "../BRDF.ush"
#include "LumenOctahedralProbe.ush"
#include "LumenScreenProbeCommon.ush"
#include "../MonteCarlo.ush"
#include "../ShadingModelsSampling.ush"
#include "../SHCommon.ush"
#include "../SceneTextureParameters.ush"
#include "../SphericalGaussian.ush"
#include "../FastMath.ush"
#include "../ClearCoatCommon.ush"
#include "LumenRadianceCacheCommon.ush"

#ifndef THREADGROUP_SIZE
#define THREADGROUP_SIZE 1
#endif

RWTexture2D<float> RWOctahedralSolidAngleTexture;
uint OctahedralSolidAngleTextureSize;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void OctahedralSolidAngleCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	if (all(DispatchThreadId.xy < OctahedralSolidAngleTextureSize))
	{
		float2 ProbeTexelCenter = float2(0.5, 0.5);
		float2 ProbeUV = (DispatchThreadId.xy + ProbeTexelCenter) / (float)OctahedralSolidAngleTextureSize;
		float SolidAngle = OctahedralSolidAngle(ProbeUV, 1.0f / (float)OctahedralSolidAngleTextureSize);
		RWOctahedralSolidAngleTexture[DispatchThreadId.xy] = SolidAngle;
	}
}

RWTexture2D<uint> RWScreenProbeSceneDepth;
RWTexture2D<float> RWScreenProbeWorldSpeed;

struct FScreenProbeGBuffer
{
	float3 WorldNormal;
	float SceneDepth;
	bool bLit;
};

FScreenProbeGBuffer GetScreenProbeGBuffer(FGBufferData GBufferData)
{ 
	FScreenProbeGBuffer ScreenProbeGBuffer;
	ScreenProbeGBuffer.WorldNormal = GBufferData.WorldNormal;
	ScreenProbeGBuffer.SceneDepth = GBufferData.Depth;
	ScreenProbeGBuffer.bLit = GBufferData.ShadingModelID != SHADINGMODELID_UNLIT;
	return ScreenProbeGBuffer;
}

void WriteDownsampledProbeGBuffer(float2 ScreenUV, uint2 ScreenProbeAtlasCoord, FScreenProbeGBuffer ProbeGBuffer)
{
	float EncodedDepth = ProbeGBuffer.SceneDepth;

	if (!ProbeGBuffer.bLit)
	{
		// Store unlit in sign bit
		EncodedDepth *= -1.0f;
	}

	RWScreenProbeSceneDepth[ScreenProbeAtlasCoord] = asuint(EncodedDepth);

	float3 ProbeWorldVelocity;
	{
		float2 ProbeScreenPosition = (ScreenUV - View.ScreenPositionScaleBias.wz) / View.ScreenPositionScaleBias.xy;

		float ProbeDeviceZ = ConvertToDeviceZ(ProbeGBuffer.SceneDepth);
		float3 ProbeHistoryScreenPosition = GetHistoryScreenPosition(ProbeScreenPosition, ScreenUV, ProbeDeviceZ);

		float3 ProbeTranslatedWorldPosition = mul(float4(ProbeScreenPosition * ProbeGBuffer.SceneDepth, ProbeGBuffer.SceneDepth, 1), View.ScreenToTranslatedWorld).xyz;
		ProbeWorldVelocity = ProbeTranslatedWorldPosition - GetPrevTranslatedWorldPosition(ProbeHistoryScreenPosition);
	}

	RWScreenProbeWorldSpeed[ScreenProbeAtlasCoord] = length(ProbeWorldVelocity);
}

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void ScreenProbeDownsampleDepthUniformCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint2 ScreenProbeAtlasCoord = DispatchThreadId.xy;

	if (all(ScreenProbeAtlasCoord < ScreenProbeAtlasViewSize))
	{
		uint2 ScreenJitter = GetScreenTileJitter(SCREEN_TEMPORAL_INDEX);
		uint2 ScreenProbeScreenPosition = min((uint2)(ScreenProbeAtlasCoord * ScreenProbeDownsampleFactor + ScreenJitter), (uint2)(View.ViewRectMin.xy + View.ViewSizeAndInvSize.xy) - 1);
		float2 ScreenUV = (ScreenProbeScreenPosition + .5f) * View.BufferSizeAndInvSize.zw;
		FGBufferData GBufferData = GetGBufferDataUint(ScreenProbeScreenPosition);
		
		WriteDownsampledProbeGBuffer(ScreenUV, ScreenProbeAtlasCoord, GetScreenProbeGBuffer(GBufferData));
	}
}

float GetScreenProbeDepthFromUAV(uint2 ScreenProbeAtlasCoord)
{
	return asfloat(RWScreenProbeSceneDepth[ScreenProbeAtlasCoord]);
}

void CalculateUniformUpsampleInterpolationWeights(
	uint2 SVPosition, 
	float2 NoiseOffset, 
	float3 WorldPosition, 
	float SceneDepth, 
	float3 WorldNormal, 
	uniform bool bIsUpsamplePass,
	out uint2 ScreenTileCoord00, 
	out float4 InterpolationWeights)
{
	uint2 ScreenProbeFullResScreenCoord = clamp(SVPosition.xy - View.ViewRectMin.xy - (int2)GetScreenTileJitter(SCREEN_TEMPORAL_INDEX) + NoiseOffset, 0, (int2)View.ViewSizeAndInvSize.xy - 1);
	ScreenTileCoord00 = min(ScreenProbeFullResScreenCoord / ScreenProbeDownsampleFactor, (uint2)ScreenProbeViewSize - 2);

	uint BilinearExpand = 0;
	float2 BilinearWeights = (ScreenProbeFullResScreenCoord - ScreenTileCoord00 * ScreenProbeDownsampleFactor + BilinearExpand) / (float)(ScreenProbeDownsampleFactor + 2 * BilinearExpand);

	float4 CornerDepths;
	CornerDepths.x = bIsUpsamplePass ? GetScreenProbeDepth(ScreenTileCoord00) : GetScreenProbeDepthFromUAV(ScreenTileCoord00);
	CornerDepths.y = bIsUpsamplePass ? GetScreenProbeDepth(ScreenTileCoord00 + int2(1, 0)) : GetScreenProbeDepthFromUAV(ScreenTileCoord00 + int2(1, 0));
	CornerDepths.z = bIsUpsamplePass ? GetScreenProbeDepth(ScreenTileCoord00 + int2(0, 1)) : GetScreenProbeDepthFromUAV(ScreenTileCoord00 + int2(0, 1));
	CornerDepths.w = bIsUpsamplePass ? GetScreenProbeDepth(ScreenTileCoord00 + int2(1, 1)) : GetScreenProbeDepthFromUAV(ScreenTileCoord00 + int2(1, 1));

	InterpolationWeights = float4(
		(1 - BilinearWeights.y) * (1 - BilinearWeights.x),
		(1 - BilinearWeights.y) * BilinearWeights.x,
		BilinearWeights.y * (1 - BilinearWeights.x),
		BilinearWeights.y * BilinearWeights.x);

	float4 DepthWeights;

#define PLANE_WEIGHTING 1
#if PLANE_WEIGHTING
	{
		float4 ScenePlane = float4(WorldNormal, dot(WorldPosition, WorldNormal));

		float3 Position00 = GetWorldPositionFromScreenUV(GetScreenUVFromScreenTileCoord(ScreenTileCoord00), CornerDepths.x);
		float3 Position10 = GetWorldPositionFromScreenUV(GetScreenUVFromScreenTileCoord(ScreenTileCoord00 + uint2(1, 0)), CornerDepths.y);
		float3 Position01 = GetWorldPositionFromScreenUV(GetScreenUVFromScreenTileCoord(ScreenTileCoord00 + uint2(0, 1)), CornerDepths.z);
		float3 Position11 = GetWorldPositionFromScreenUV(GetScreenUVFromScreenTileCoord(ScreenTileCoord00 + uint2(1, 1)), CornerDepths.w);

		float4 PlaneDistances;
		PlaneDistances.x = abs(dot(float4(Position00, -1), ScenePlane));
		PlaneDistances.y = abs(dot(float4(Position10, -1), ScenePlane));
		PlaneDistances.z = abs(dot(float4(Position01, -1), ScenePlane));
		PlaneDistances.w = abs(dot(float4(Position11, -1), ScenePlane));
			
		float4 RelativeDepthDifference = PlaneDistances / SceneDepth;

		DepthWeights = CornerDepths > 0 ? exp2(-10000.0f * (RelativeDepthDifference * RelativeDepthDifference)) : 0;
	}
#else
	{
		float4 DepthDifference = abs(CornerDepths - SceneDepth.xxxx);
		float4 RelativeDepthDifference = DepthDifference / SceneDepth;
		DepthWeights = CornerDepths > 0 ? exp2(-100.0f * (RelativeDepthDifference * RelativeDepthDifference)) : 0;
	}
#endif

	InterpolationWeights *= DepthWeights;
}

RWTexture2D<uint> RWScreenTileAdaptiveProbeHeader;
RWTexture2D<uint> RWScreenTileAdaptiveProbeIndices;
RWBuffer<uint> RWAdaptiveScreenProbeData;

void CalculateUpsampleInterpolationWeights(
	uint2 SVPosition,
	float2 NoiseOffset,
	float3 WorldPosition,
	float SceneDepth,
	float3 WorldNormal,
	uniform bool bIsUpsamplePass,
	out uint2 ScreenProbeAtlasCoordArray[4],
	out float4 InterpolationWeights)
{
	uint2 ScreenTileCoord00;
	CalculateUniformUpsampleInterpolationWeights(SVPosition, NoiseOffset, WorldPosition, SceneDepth, WorldNormal, bIsUpsamplePass, ScreenTileCoord00, InterpolationWeights);

	ScreenProbeAtlasCoordArray[0] = ScreenTileCoord00;
	ScreenProbeAtlasCoordArray[1] = ScreenTileCoord00 + uint2(1, 0);
	ScreenProbeAtlasCoordArray[2] = ScreenTileCoord00 + uint2(0, 1);
	ScreenProbeAtlasCoordArray[3] = ScreenTileCoord00 + uint2(1, 1);

	bool bUseAdaptiveProbesForUpsample = true;

	if (bUseAdaptiveProbesForUpsample || !bIsUpsamplePass)
	{		
		float Epsilon = .01f;
		float4 ScenePlane = float4(WorldNormal, dot(WorldPosition, WorldNormal));

		UNROLL
		for (uint CornerIndex = 0; CornerIndex < 4; CornerIndex++)
		{
			if (InterpolationWeights[CornerIndex] <= Epsilon)
			{
				uint2 ScreenTileCoord = ScreenTileCoord00 + uint2(CornerIndex % 2, CornerIndex / 2);
				uint NumAdaptiveProbes = bIsUpsamplePass ? ScreenTileAdaptiveProbeHeader[ScreenTileCoord] : RWScreenTileAdaptiveProbeHeader[ScreenTileCoord];

				for (uint AdaptiveProbeListIndex = 0; AdaptiveProbeListIndex < NumAdaptiveProbes; AdaptiveProbeListIndex++)
				{
					uint2 AdaptiveProbeCoord = GetAdaptiveProbeCoord(ScreenTileCoord, AdaptiveProbeListIndex);
					uint AdaptiveProbeIndex = bIsUpsamplePass ? ScreenTileAdaptiveProbeIndices[AdaptiveProbeCoord] : RWScreenTileAdaptiveProbeIndices[AdaptiveProbeCoord];
					uint ScreenProbeIndex = AdaptiveProbeIndex + NumUniformScreenProbes;

					uint2 ScreenProbeScreenPosition = bIsUpsamplePass ? GetScreenProbeScreenPosition(ScreenProbeIndex) : DecodeScreenProbeData(RWAdaptiveScreenProbeData[AdaptiveProbeIndex]);
					uint2 ScreenProbeAtlasCoord = uint2(ScreenProbeIndex % ScreenProbeAtlasViewSize.x, ScreenProbeIndex / ScreenProbeAtlasViewSize.x);
					float ProbeDepth = bIsUpsamplePass ? GetScreenProbeDepth(ScreenProbeAtlasCoord) : GetScreenProbeDepthFromUAV(ScreenProbeAtlasCoord);
					
					float NewDepthWeight = 0;
					bool bPlaneWeighting = true;
					if (bPlaneWeighting)
					{
						float3 ProbePosition = GetWorldPositionFromScreenUV(GetScreenUVFromScreenProbePosition(ScreenProbeScreenPosition), ProbeDepth);
						float PlaneDistance = abs(dot(float4(ProbePosition, -1), ScenePlane));
						float RelativeDepthDifference = PlaneDistance / SceneDepth;
						NewDepthWeight = exp2(-10000.0f * (RelativeDepthDifference * RelativeDepthDifference));
					}
					else
					{
						float DepthDifference = abs(ProbeDepth - SceneDepth);
						float RelativeDepthDifference = DepthDifference / SceneDepth;
						NewDepthWeight = ProbeDepth > 0 ? exp2(-100.0f * (RelativeDepthDifference * RelativeDepthDifference)) : 0;
					}

					float2 DistanceToScreenProbe = abs(ScreenProbeScreenPosition - SVPosition);
					float NewCornerWeight = 1.0f - saturate(min(DistanceToScreenProbe.x, DistanceToScreenProbe.y) / (float)ScreenProbeDownsampleFactor);
					float NewInterpolationWeight = NewDepthWeight * NewCornerWeight;

					if (NewInterpolationWeight > InterpolationWeights[CornerIndex])
					{
						InterpolationWeights[CornerIndex] = NewInterpolationWeight;
						ScreenProbeAtlasCoordArray[CornerIndex] = ScreenProbeAtlasCoord;
					}
				}
			}
		}
	}
}

RWBuffer<uint> RWNumAdaptiveScreenProbes;

groupshared uint SharedNumProbesToAllocate;
groupshared uint SharedAdaptiveProbeBaseIndex;
groupshared uint2 SharedProbeScreenPositionsToAllocate[THREADGROUP_SIZE * THREADGROUP_SIZE];
groupshared FScreenProbeGBuffer SharedScreenProbeGBuffer[THREADGROUP_SIZE * THREADGROUP_SIZE];

uint PlacementDownsampleFactor;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void ScreenProbeAdaptivePlacementCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint ThreadIndex = GroupThreadId.y * THREADGROUP_SIZE + GroupThreadId.x;

	if (ThreadIndex == 0)
	{
		SharedNumProbesToAllocate = 0;
	}

	GroupMemoryBarrierWithGroupSync();

	{
		uint2 ScreenProbeScreenPosition = DispatchThreadId.xy * PlacementDownsampleFactor + GetScreenTileJitter(SCREEN_TEMPORAL_INDEX) + (uint2)View.ViewRectMin.xy;

		if (all(ScreenProbeScreenPosition < (uint2)(View.ViewRectMin.xy + View.ViewSizeAndInvSize.xy)) && any((DispatchThreadId.xy & 0x1) != 0))
		{
			FGBufferData GBufferData = GetGBufferDataUint(ScreenProbeScreenPosition);

			if (GBufferData.ShadingModelID != SHADINGMODELID_UNLIT)
			{
				float2 ScreenUV = (ScreenProbeScreenPosition + .5f) * View.BufferSizeAndInvSize.zw;
				float3 WorldPosition = GetWorldPositionFromScreenUV(ScreenUV, GBufferData.Depth);
				float2 NoiseOffset = 0.0f;
				uint2 ScreenProbeAtlasCoord[4];
				float4 InterpolationWeights;

				CalculateUpsampleInterpolationWeights(
					ScreenProbeScreenPosition,
					NoiseOffset,
					WorldPosition,
					GBufferData.Depth,
					GBufferData.WorldNormal,
					false,
					ScreenProbeAtlasCoord,
					InterpolationWeights);

				float Epsilon = .01f;
				InterpolationWeights /= max(dot(InterpolationWeights, 1), Epsilon);

				float LightingIsValid = (dot(InterpolationWeights, 1) < 1.0f - Epsilon) ? 0.0f : 1.0f;

				if (!LightingIsValid)
				{
					uint SharedListIndex;
					InterlockedAdd(SharedNumProbesToAllocate, 1, SharedListIndex);
					SharedProbeScreenPositionsToAllocate[SharedListIndex] = ScreenProbeScreenPosition;
					SharedScreenProbeGBuffer[SharedListIndex] = GetScreenProbeGBuffer(GBufferData);
				}
			}
		}
	}

	GroupMemoryBarrierWithGroupSync();

	if (ThreadIndex == 0)
	{
		InterlockedAdd(RWNumAdaptiveScreenProbes[0], SharedNumProbesToAllocate, SharedAdaptiveProbeBaseIndex);
	}

	GroupMemoryBarrierWithGroupSync();

	uint AdaptiveProbeIndex = ThreadIndex + SharedAdaptiveProbeBaseIndex;

	if (ThreadIndex < SharedNumProbesToAllocate && AdaptiveProbeIndex < MaxNumAdaptiveProbes)
	{
		uint2 ScreenProbeScreenPosition = SharedProbeScreenPositionsToAllocate[ThreadIndex];
		RWAdaptiveScreenProbeData[AdaptiveProbeIndex] = EncodeScreenProbeData(ScreenProbeScreenPosition);
		uint2 ScreenTileCoord = GetScreenTileCoord(ScreenProbeScreenPosition);

		uint TileProbeIndex;
		InterlockedAdd(RWScreenTileAdaptiveProbeHeader[ScreenTileCoord], 1, TileProbeIndex);
		uint2 AdaptiveProbeCoord = GetAdaptiveProbeCoord(ScreenTileCoord, TileProbeIndex);
		RWScreenTileAdaptiveProbeIndices[AdaptiveProbeCoord] = AdaptiveProbeIndex;
		
		float2 ScreenUV = (ScreenProbeScreenPosition + .5f) * View.BufferSizeAndInvSize.zw;
		uint ScreenProbeIndex = NumUniformScreenProbes + AdaptiveProbeIndex;
		uint2 ScreenProbeAtlasCoord = uint2(ScreenProbeIndex % ScreenProbeAtlasViewSize.x, ScreenProbeIndex / ScreenProbeAtlasViewSize.x);
		WriteDownsampledProbeGBuffer(ScreenUV, ScreenProbeAtlasCoord, SharedScreenProbeGBuffer[ThreadIndex]);
	}
}

RWBuffer<uint> RWScreenProbeIndirectArgs;

void WriteArgs2D(uint Index, uint2 ThreadCount)
{
	RWScreenProbeIndirectArgs[Index * 3 + 0] = (ThreadCount.x +	PROBE_THREADGROUP_SIZE_2D - 1) / PROBE_THREADGROUP_SIZE_2D;
	RWScreenProbeIndirectArgs[Index * 3 + 1] = (ThreadCount.y + PROBE_THREADGROUP_SIZE_2D - 1) / PROBE_THREADGROUP_SIZE_2D;
	RWScreenProbeIndirectArgs[Index * 3 + 2] = 1;
}

[numthreads(1, 1, 1)]
void SetupAdaptiveProbeIndirectArgsCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint2 AtlasSizeInProbes = uint2(ScreenProbeAtlasViewSize.x, (GetNumScreenProbes() + ScreenProbeAtlasViewSize.x - 1) / ScreenProbeAtlasViewSize.x);

	// Must match EScreenProbeIndirectArgs in C++
	WriteArgs2D(0, AtlasSizeInProbes * PROBE_THREADGROUP_SIZE_2D);
	WriteArgs2D(1, AtlasSizeInProbes);
	WriteArgs2D(2, AtlasSizeInProbes * ScreenProbeTracingOctahedronResolution);
	WriteArgs2D(3, AtlasSizeInProbes * ScreenProbeGatherOctahedronResolution);
	WriteArgs2D(4, AtlasSizeInProbes * ScreenProbeGatherOctahedronResolutionWithBorder);
}

[numthreads(PROBE_THREADGROUP_SIZE_2D, PROBE_THREADGROUP_SIZE_2D, 1)]
void MarkRadianceProbesUsedByScreenProbesCS(
	uint3 GroupId : SV_GroupID,
	uint3 DispatchThreadId : SV_DispatchThreadID,
	uint3 GroupThreadId : SV_GroupThreadID)
{
	uint2 ScreenProbeAtlasCoord = DispatchThreadId.xy;
	uint ScreenProbeIndex = ScreenProbeAtlasCoord.y * ScreenProbeAtlasViewSize.x + ScreenProbeAtlasCoord.x;
	uint2 ScreenProbeScreenPosition = GetScreenProbeScreenPosition(ScreenProbeIndex);

	if (ScreenProbeIndex < GetNumScreenProbes())
	{
		float2 ScreenUV = GetScreenUVFromScreenProbePosition(ScreenProbeScreenPosition);
		float SceneDepth = GetScreenProbeDepth(ScreenProbeAtlasCoord);
		float3 WorldPosition = GetWorldPositionFromScreenUV(ScreenUV, SceneDepth);

		if (SceneDepth > 0)
		{
			uint ClipmapIndex = GetRadianceProbeClipmap(WorldPosition);

			if (ClipmapIndex < NumRadianceProbeClipmaps)
			{
				//@todo - cull by screen size
				//@todo - cull probes too small for voxel tracing and too large for max trace distance
				MarkPositionUsedInIndirectionTexture(WorldPosition, ClipmapIndex);
			}
		}
	}
}

Buffer<float3> ScreenProbeRadianceSHAmbient;
Buffer<float4> ScreenProbeRadianceSHDirectional;

FThreeBandSHVectorRGB GetScreenProbeSH(uint2 ScreenProbeAtlasCoord, float InterpolationWeight)
{
	uint AmbientReadIndex = (ScreenProbeAtlasCoord.y * ScreenProbeAtlasViewSize.x + ScreenProbeAtlasCoord.x);
	float3 AmbientVector = ScreenProbeRadianceSHAmbient.Load(AmbientReadIndex).xyz;

	float4 SHCoefficients0Red = ScreenProbeRadianceSHDirectional.Load((AmbientReadIndex * 3 + 0) * 2 + 0);
	float4 SHCoefficients1Red = ScreenProbeRadianceSHDirectional.Load((AmbientReadIndex * 3 + 0) * 2 + 1);
	float4 SHCoefficients0Green = ScreenProbeRadianceSHDirectional.Load((AmbientReadIndex * 3 + 1) * 2 + 0);
	float4 SHCoefficients1Green = ScreenProbeRadianceSHDirectional.Load((AmbientReadIndex * 3 + 1) * 2 + 1);
	float4 SHCoefficients0Blue = ScreenProbeRadianceSHDirectional.Load((AmbientReadIndex * 3 + 2) * 2 + 0);
	float4 SHCoefficients1Blue = ScreenProbeRadianceSHDirectional.Load((AmbientReadIndex * 3 + 2) * 2 + 1);

#if SH_QUANTIZE_DIRECTIONAL_COEFFICIENTS
	float4 SHDenormalizationScales0 = float4(
		0.488603f / 0.282095f, 
		0.488603f / 0.282095f, 
		0.488603f / 0.282095f, 
		1.092548f / 0.282095f);

	float4 SHDenormalizationScales1 = float4(
		1.092548f / 0.282095f,
		4.0f * 0.315392f / 0.282095f,
		1.092548f / 0.282095f,
		2.0f * 0.546274f / 0.282095f);

	SHCoefficients0Red = (SHCoefficients0Red * 2 - 1) * AmbientVector.x * SHDenormalizationScales0;
	SHCoefficients1Red = (SHCoefficients1Red * 2 - 1) * AmbientVector.x * SHDenormalizationScales1;
	SHCoefficients0Green = (SHCoefficients0Green * 2 - 1) * AmbientVector.y * SHDenormalizationScales0;
	SHCoefficients1Green = (SHCoefficients1Green * 2 - 1) * AmbientVector.y * SHDenormalizationScales1;
	SHCoefficients0Blue = (SHCoefficients0Blue * 2 - 1) * AmbientVector.z * SHDenormalizationScales0;
	SHCoefficients1Blue = (SHCoefficients1Blue * 2 - 1) * AmbientVector.z * SHDenormalizationScales1;
#endif

	FThreeBandSHVectorRGB LightingSH;
	LightingSH.R.V0 = float4(AmbientVector.x, SHCoefficients0Red.xyz) * InterpolationWeight;
	LightingSH.R.V1 = float4(SHCoefficients0Red.w, SHCoefficients1Red.xyz) * InterpolationWeight;
	LightingSH.R.V2 = SHCoefficients1Red.w * InterpolationWeight;
	LightingSH.G.V0 = float4(AmbientVector.y, SHCoefficients0Green.xyz) * InterpolationWeight;
	LightingSH.G.V1 = float4(SHCoefficients0Green.w, SHCoefficients1Green.xyz) * InterpolationWeight;
	LightingSH.G.V2 = SHCoefficients1Green.w * InterpolationWeight;
	LightingSH.B.V0 = float4(AmbientVector.z, SHCoefficients0Blue.xyz) * InterpolationWeight;
	LightingSH.B.V1 = float4(SHCoefficients0Blue.w, SHCoefficients1Blue.xyz) * InterpolationWeight;
	LightingSH.B.V2 = SHCoefficients1Blue.w * InterpolationWeight;

	return LightingSH;
}

Buffer<float> ScreenProbeMoving;

float GetScreenProbeMoving(uint2 ScreenProbeAtlasCoord, float InterpolationWeight)
{
	return ScreenProbeMoving[ScreenProbeAtlasCoord.y * ScreenProbeAtlasViewSize.x + ScreenProbeAtlasCoord.x] * InterpolationWeight;
}

// Bias the important sampling of SampleBxDF(SHADING_TERM_SPECULAR, ....)
float4 BiasBSDFImportantSample(float4 E)
{
	float Bias = 1.0 - 0.1;

	E.y = (E.y - 0.5) * Bias + 0.5;

	return E;
}

Texture2D<float3> ScreenProbeRadianceWithBorder;
Texture2D<float3> ScreenProbeRadiance;

float3 InterpolateFromScreenProbes(float3 ConeDirection, float MipLevel, uint2 ScreenProbeAtlasCoord[4], float4 InterpolationWeights)
{
	float BorderSize = 1 << (uint)ScreenProbeGatherMaxMip;
	float2 ProbeCoord = DirectionToOctahedralMap(ConeDirection) * ScreenProbeGatherOctahedronResolution;
					
	float2 InvBufferSize = 1.0f / (float2)(ScreenProbeGatherOctahedronResolutionWithBorder * ScreenProbeAtlasBufferSize);
	float2 UVMul = ScreenProbeGatherOctahedronResolutionWithBorder * InvBufferSize;
	float2 UVAdd = (ProbeCoord + BorderSize) * InvBufferSize;

	float2 UV0 = ScreenProbeAtlasCoord[0] * UVMul + UVAdd;
	float3 InterpolatedRadiance = InterpolationWeights.x > 0 ? ScreenProbeRadianceWithBorder.SampleLevel(GlobalBilinearClampedSampler, UV0, MipLevel).xyz * InterpolationWeights.x : 0;

	float2 UV1 = ScreenProbeAtlasCoord[1] * UVMul + UVAdd;
	InterpolatedRadiance += InterpolationWeights.y > 0 ? ScreenProbeRadianceWithBorder.SampleLevel(GlobalBilinearClampedSampler, UV1, MipLevel).xyz * InterpolationWeights.y : 0;

	float2 UV2 = ScreenProbeAtlasCoord[2] * UVMul + UVAdd;
	InterpolatedRadiance += InterpolationWeights.z > 0 ? ScreenProbeRadianceWithBorder.SampleLevel(GlobalBilinearClampedSampler, UV2, MipLevel).xyz * InterpolationWeights.z : 0;

	float2 UV3 = ScreenProbeAtlasCoord[3] * UVMul + UVAdd;
	InterpolatedRadiance += InterpolationWeights.w > 0 ? ScreenProbeRadianceWithBorder.SampleLevel(GlobalBilinearClampedSampler, UV3, MipLevel).xyz * InterpolationWeights.w : 0;
	return InterpolatedRadiance;
}

void DebugVisualizeScreenProbePlacement(uint2 SVPosition, inout float3 DiffuseIndirectOutput)
{
	#define DEBUG_VISUALIZE_SCREEN_PROBE_PLACEMENT 0
	#if DEBUG_VISUALIZE_SCREEN_PROBE_PLACEMENT
		uint2 ScreenTileCoord = GetScreenTileCoord(SVPosition);
		uint2 UniformScreenProbeScreenPosition = GetUniformScreenProbeScreenPosition(ScreenTileCoord);

		if (all(UniformScreenProbeScreenPosition == SVPosition) && GetScreenProbeDepth(ScreenTileCoord) >= 0)
		{
			DiffuseIndirectOutput = float3(20, 0, 20);
		}

		uint NumAdaptiveProbes = ScreenTileAdaptiveProbeHeader[ScreenTileCoord];

		for (uint AdaptiveProbeListIndex = 0; AdaptiveProbeListIndex < NumAdaptiveProbes; AdaptiveProbeListIndex++)
		{
			uint2 AdaptiveProbeCoord = GetAdaptiveProbeCoord(ScreenTileCoord, AdaptiveProbeListIndex);
			uint AdaptiveProbeIndex = ScreenTileAdaptiveProbeIndices[AdaptiveProbeCoord];
			uint ScreenProbeIndex = AdaptiveProbeIndex + NumUniformScreenProbes;

			uint2 ScreenProbeScreenPosition = GetScreenProbeScreenPosition(ScreenProbeIndex);

			if (all(ScreenProbeScreenPosition == SVPosition))
			{
				DiffuseIndirectOutput = float3(20, 0, 20);
			}
		}

		//DiffuseIndirectOutput = NumAdaptiveProbes / 10.0f;
	#endif
}

float FullResolutionJitterWidth;
uint UseScreenBentNormal;
Texture2D<float3> ScreenBentNormal;

#ifndef DIFFUSE_INTEGRAL_METHOD
#define DIFFUSE_INTEGRAL_METHOD 0
#endif

bool RequiresBxDFImportanceSampling(uint ShadingModelID)
{
	switch (ShadingModelID)
	{
	case SHADINGMODELID_HAIR:
		return true;
	default:
		return false;
	}
}

float IrradianceBounce0Rescale(float AO)
{
	return AO * (1 + (1 - AO) / (2 * sqrt(sqrt(1 - AO))));
}

float IrradianceBounce1Rescale(float AO)
{
	float A = 27.576937094210385f;
	float B = 3.3364392003423804f;
	return A * AO * pow(1 - AO, 1.5f) * exp(-B * sqrt(sqrt(AO)));
}

// From "2018 Patapom - Improved Ambient Occlusion"
float3 DistantIlluminationRescale(float3 DiffuseColor, float AO)
{
	float F0 = IrradianceBounce0Rescale(min(AO, .999f));
	float F1 = IrradianceBounce1Rescale(min(AO, .999f));
	float Tau = 1 - F1 / max(1 - F0, 0.00001f);

	return F0 + DiffuseColor / max(1 - DiffuseColor * Tau, 0.00001f) * F1;
}

RWTexture2D<float4> RWDiffuseIndirect;
RWTexture2D<float3> RWRoughSpecularIndirect;
float MaxRoughnessToTrace;
float RoughnessFadeLength;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void ScreenProbeIndirectCS(
	uint2 DispatchThreadId : SV_DispatchThreadID)
{
	float2 ScreenUV = (DispatchThreadId + 0.5) * View.BufferSizeAndInvSize.zw;
	float SceneDepth = CalcSceneDepth(ScreenUV);

	{
		FScreenSpaceData ScreenSpaceData = GetScreenSpaceData(ScreenUV);
		FGBufferData GBufferData = ScreenSpaceData.GBuffer;
		
		if (GBufferData.ShadingModelID != SHADINGMODELID_UNLIT)
		{
			float3 WorldPosition = GetWorldPositionFromScreenUV(ScreenUV, SceneDepth);

			float2 NoiseOffset = 0.0f;

			if (FullResolutionJitterWidth > 0)
			{
				//@todo - expose fade distance
				float EffectiveJitterWidth = FullResolutionJitterWidth * lerp(1.0f, .5f, saturate((SceneDepth - 500.0f) / 500.0f));
				uint2 RandomSeed = Rand3DPCG16(int3(DispatchThreadId.xy, GENERAL_TEMPORAL_INDEX)).xy;
				float2 ScreenTileJitterE = Hammersley16(0, 1, RandomSeed);
				//float2 ScreenTileJitterE = EvalBlueNoise(DispatchThreadId.xy % BlueNoise.Dimensions.xy, RAY_DIRECTION_TEMPORAL_INDEX % BlueNoise.Dimensions.z).xy;
				float2 JitterNoiseOffset = (ScreenTileJitterE * 2 - 1) * ScreenProbeDownsampleFactor * EffectiveJitterWidth;

				float2 JitteredScreenUV = clamp(DispatchThreadId.xy + JitterNoiseOffset, View.ViewRectMin.xy, View.ViewSizeAndInvSize.xy - 1) * View.BufferSizeAndInvSize.zw;
				float JitteredSceneDepth = CalcSceneDepth(JitteredScreenUV);

				float DepthWeight;

				{
					float4 ScenePlane = float4(GBufferData.WorldNormal, dot(WorldPosition, GBufferData.WorldNormal));
					float3 JitteredPosition = GetWorldPositionFromScreenUV(JitteredScreenUV, JitteredSceneDepth);
					float PlaneDistance = abs(dot(float4(JitteredPosition, -1), ScenePlane));
					float RelativeDepthDifference = PlaneDistance / SceneDepth;
					DepthWeight = exp2(-1000000.0f * (RelativeDepthDifference * RelativeDepthDifference));
				}

				if (DepthWeight > .01f)
				{
					NoiseOffset = JitterNoiseOffset;
				}
			}

			uint2 ScreenProbeAtlasCoord[4];
			float4 InterpolationWeights;

			CalculateUpsampleInterpolationWeights(
				DispatchThreadId.xy,
				NoiseOffset,
				WorldPosition,
				SceneDepth,
				GBufferData.WorldNormal,
				true,
				ScreenProbeAtlasCoord,
				InterpolationWeights);

			float Epsilon = .01f;
			InterpolationWeights /= max(dot(InterpolationWeights, 1), Epsilon);

			float3 V = normalize(View.WorldCameraOrigin - WorldPosition);
			float3 UnitBentNormal = GBufferData.WorldNormal;
			float AO = 1.0f;
			float3 DiffuseLighting = 0;

			#define SCREEN_SPACE_BENT_NORMAL 1
			#if SCREEN_SPACE_BENT_NORMAL 
			if (UseScreenBentNormal > 0)
			{
				float3 BentNormal = ScreenBentNormal[DispatchThreadId.xy] * 2 - 1;
				AO = length(BentNormal);
				UnitBentNormal = AO > 0 ? BentNormal / AO : GBufferData.WorldNormal;
			}
			#endif

// Highest quality and fastest for diffuse
#define SPHERICAL_HARMONIC 0
// Noisy and slow, but handles any shading model and GBuffer bent normal AO
#define IMPORTANCE_SAMPLE_BRDF 1
// Slow reference
#define NUMERICAL_INTEGRAL 2

			uint DiffuseIntegrationMethod = RequiresBxDFImportanceSampling(GBufferData.ShadingModelID) ? IMPORTANCE_SAMPLE_BRDF : DIFFUSE_INTEGRAL_METHOD;
			
			#if GBUFFER_HAS_DIFFUSE_SAMPLE_OCCLUSION
			if (GBufferData.DiffuseIndirectSampleOcclusion != 0)
			{
				DiffuseIntegrationMethod = IMPORTANCE_SAMPLE_BRDF;
			}
			#endif

			if (DiffuseIntegrationMethod == SPHERICAL_HARMONIC)
			{
				FThreeBandSHVectorRGB LightingSH = GetScreenProbeSH(ScreenProbeAtlasCoord[0], InterpolationWeights.x);
				LightingSH = AddSH(LightingSH, GetScreenProbeSH(ScreenProbeAtlasCoord[1], InterpolationWeights.y));
				LightingSH = AddSH(LightingSH, GetScreenProbeSH(ScreenProbeAtlasCoord[2], InterpolationWeights.z));
				LightingSH = AddSH(LightingSH, GetScreenProbeSH(ScreenProbeAtlasCoord[3], InterpolationWeights.w));

				float3 ProbeLightingNormal = GBufferData.WorldNormal;

				#if SCREEN_SPACE_BENT_NORMAL 
					// Use more bent normal in occluded corners
					ProbeLightingNormal = normalize(lerp(UnitBentNormal, GBufferData.WorldNormal, AO));
				#endif

				float3 SHDiffuseLighting = EvaluateSHIrradiance(ProbeLightingNormal, 1 - AO, LightingSH);
				
				DiffuseLighting += 4 * PI * SHDiffuseLighting;
			}
			else if (DiffuseIntegrationMethod == IMPORTANCE_SAMPLE_BRDF)
			{
				// This could be configurable if not for GBUFFER_HAS_DIFFUSE_SAMPLE_OCCLUSION
				uint NumPixelSamples = INDIRECT_SAMPLE_COUNT;
				const uint TermMask = SHADING_TERM_DIFFUSE | SHADING_TERM_HAIR_R | SHADING_TERM_HAIR_TT | SHADING_TERM_HAIR_TRT;
				//@todo - calculate based on solid angle
				float DiffuseMipLevel = ScreenProbeGatherMaxMip;
				float VisibilityThreshold = InterleavedGradientNoise(DispatchThreadId.xy, GENERAL_TEMPORAL_INDEX);
				FSphericalGaussian HemisphereSG = Hemisphere_ToSphericalGaussian(GBufferData.WorldNormal);
				FSphericalGaussian VisibleSG = BentNormalAO_ToSphericalGaussian(UnitBentNormal, AO);

				for (uint PixelRayIndex = 0; PixelRayIndex < NumPixelSamples; PixelRayIndex += 1)
				{
					float4 E = ComputeIndirectLightingSampleE(DispatchThreadId.xy, PixelRayIndex, NumPixelSamples);
					FBxDFSample BxDFSample = SampleBxDF(TermMask, GBufferData, V, E);

					float3 InterpolatedRadiance = InterpolateFromScreenProbes(BxDFSample.L, DiffuseMipLevel, ScreenProbeAtlasCoord, InterpolationWeights);

					#if GBUFFER_HAS_DIFFUSE_SAMPLE_OCCLUSION
						bool bIsBentNormalOccluded = (GBufferData.DiffuseIndirectSampleOcclusion & (1 << PixelRayIndex)) != 0;
						float DirectionVisibility = bIsBentNormalOccluded ? 0 : 1;
					#else
						float DirectionVisibility = 1.0f;
					#endif

					#if SCREEN_SPACE_BENT_NORMAL
						float LVisibility = saturate(Evaluate(VisibleSG, BxDFSample.L) / Evaluate(HemisphereSG, BxDFSample.L));
						DirectionVisibility *= LVisibility < VisibilityThreshold ? 0 : 1;
					#endif

					DiffuseLighting += InterpolatedRadiance * BxDFSample.Weight * DirectionVisibility;
				}

				DiffuseLighting = DiffuseLighting * PI / ((float)NumPixelSamples * AO);

				if (GBufferData.ShadingModelID == SHADINGMODELID_HAIR)
				{
					// Max op. prevents numerical issue which causes invalid color shift with dark albedo
					DiffuseLighting *= -min(-rcp(max(0.01f, GBufferData.BaseColor)), 0.0);
				}

				#if GBUFFER_HAS_DIFFUSE_SAMPLE_OCCLUSION
				{
					float MaterialAO = GBufferData.GBufferAO;
					DiffuseLighting *= AOMultiBounce(GBufferData.BaseColor, MaterialAO) * (MaterialAO > 0.0 ? rcp(MaterialAO) : 0.0);
				}
				#endif
			}
#if DIFFUSE_INTEGRAL_METHOD == NUMERICAL_INTEGRAL
			else
			{
				float TotalWeight = 0;
				const float InvScreenProbeResolution = 1.0f / ScreenProbeGatherOctahedronResolution;
				float ScreenProbeResolutionFloat = ScreenProbeGatherOctahedronResolution;
				FSphericalGaussian HemisphereSG = Hemisphere_ToSphericalGaussian(GBufferData.WorldNormal);
				FSphericalGaussian VisibleSG = BentNormalAO_ToSphericalGaussian(UnitBentNormal, AO);

				for (float Y = 0; Y < ScreenProbeResolutionFloat; Y++)
				{
					for (float X = 0; X < ScreenProbeResolutionFloat; X++)
					{
						float2 ProbeTexelCenter = float2(0.5, 0.5);
						float2 ProbeUV = (float2(X, Y) + ProbeTexelCenter) * InvScreenProbeResolution;
						float3 WorldConeDirection = OctahedralMapToDirection(ProbeUV);

						float NdotL = dot(WorldConeDirection, GBufferData.WorldNormal);

						if (NdotL > 0)
						{
							float SolidAngle = OctahedralSolidAngleLUT(ProbeUV, ScreenProbeGatherOctahedronResolution);

							#if 1
								float SampleWeight = NdotL * SolidAngle;
							#else
								FShadowTerms Shadow = { 1, 1, 1, InitHairTransmittanceData() };
								FDirectLighting BxDFSample = EvaluateBxDF(GBufferData, GBufferData.WorldNormal, V, WorldConeDirection, saturate(NdotL), Shadow);

								float3 SampleWeight = BxDFSample.Diffuse * SolidAngle;
							#endif
							
							float3 InterpolatedRadiance;

							uint2 ProbeCoord = uint2(X, Y);
							InterpolatedRadiance = InterpolationWeights.x > 0 ? ScreenProbeRadiance.Load(int3(ScreenProbeAtlasCoord[0] * ScreenProbeGatherOctahedronResolution + ProbeCoord, 0)).xyz * InterpolationWeights.x : 0;
							
							if (InterpolationWeights.y > 0)
							{
								InterpolatedRadiance += ScreenProbeRadiance.Load(int3(ScreenProbeAtlasCoord[1] * ScreenProbeGatherOctahedronResolution + ProbeCoord, 0)).xyz * InterpolationWeights.y;
							}
							if (InterpolationWeights.z > 0)
							{
								InterpolatedRadiance += ScreenProbeRadiance.Load(int3(ScreenProbeAtlasCoord[2] * ScreenProbeGatherOctahedronResolution + ProbeCoord, 0)).xyz * InterpolationWeights.z;
							}
							if (InterpolationWeights.w > 0)
							{
								InterpolatedRadiance += ScreenProbeRadiance.Load(int3(ScreenProbeAtlasCoord[3] * ScreenProbeGatherOctahedronResolution + ProbeCoord, 0)).xyz * InterpolationWeights.w;
							}
							float DirectionalOcclusion = 1.0f;

							#if SCREEN_SPACE_BENT_NORMAL
								float VisibilityThreshold = InterleavedGradientNoise(DispatchThreadId.xy * float2(ScreenProbeResolutionFloat, ScreenProbeResolutionFloat) + float2(X, Y), GENERAL_TEMPORAL_INDEX);
								float LVisibility = saturate(Evaluate(VisibleSG, WorldConeDirection) / Evaluate(HemisphereSG, WorldConeDirection));
								DirectionalOcclusion *= LVisibility < VisibilityThreshold ? 0 : 1;
							#endif

							DiffuseLighting += InterpolatedRadiance * SampleWeight * DirectionalOcclusion;
							TotalWeight += SampleWeight;
						}
					}
				}

				if (TotalWeight > 0)
				{
					DiffuseLighting = DiffuseLighting * PI / (TotalWeight * AO);
				}
			}
#endif
			bool bLightingIsValid = dot(InterpolationWeights, 1) > 1.0f - Epsilon;

			#if SCREEN_SPACE_BENT_NORMAL
			{
				DiffuseLighting *= DistantIlluminationRescale(GBufferData.BaseColor, AO);
			}
			#endif

			float LightingIsMoving = GetScreenProbeMoving(ScreenProbeAtlasCoord[0], InterpolationWeights.x)
				+ GetScreenProbeMoving(ScreenProbeAtlasCoord[1], InterpolationWeights.y)
				+ GetScreenProbeMoving(ScreenProbeAtlasCoord[2], InterpolationWeights.z)
				+ GetScreenProbeMoving(ScreenProbeAtlasCoord[3], InterpolationWeights.w);

			float EncodedAlpha = (bLightingIsValid ? 1.0f : -1.0f) * max(LightingIsMoving, .001f);

			float3 DiffuseIndirectOutput = DiffuseLighting * (bLightingIsValid ? 1.0f : 0.0f) * Diffuse_Lambert(float3(1, 1, 1));

			DebugVisualizeScreenProbePlacement(DispatchThreadId, DiffuseIndirectOutput);

			#define DEBUG_VISUALIZE_INVALID_UPSAMPLE 0
			#if DEBUG_VISUALIZE_INVALID_UPSAMPLE
				if (!bLightingIsValid)
				{
					DiffuseIndirectOutput = float3(10, 0, 0);
				}
			#endif

			// FDiffuseIndirectCompositePS applies DiffuseColor
			RWDiffuseIndirect[DispatchThreadId.xy] = float4(DiffuseIndirectOutput, EncodedAlpha);

			float3 SpecularLighting = 0;

#define COMPUTE_ROUGH_SPECULAR 1
#if COMPUTE_ROUGH_SPECULAR

			float DiffuseLerp = saturate((GBufferData.Roughness - .5f) / .3f);
			uint NumSpecularSamples = 4;

			// Prevent NaNs from ImportanceSampleVisibleGGX
			GBufferData.Roughness = max(GBufferData.Roughness, .01f);

			float MinRoughnessForProbeImportanceSampling = MaxRoughnessToTrace - RoughnessFadeLength;

			if (DiffuseLerp < 1.0f && GBufferData.Roughness >= MinRoughnessForProbeImportanceSampling || GBufferData.ShadingModelID == SHADINGMODELID_CLEAR_COAT)
			{
				GBufferData.WorldNormal = GetClearCoatBottomNormal(GBufferData, GBufferData.WorldNormal);

				//@todo - derive mip from cone angle from roughness
				
				// Approximation made to move out of inner loop
				float RayPDFForMip = 1.0f;
				float SolidAngleSample = 1.0 / (NumSpecularSamples * RayPDFForMip);
				float CosConeHalfAngle = 1.0 - SolidAngleSample / (2.0 * PI);
				float NumTexels = sqrt(1.0f - CosConeHalfAngle) * ScreenProbeGatherOctahedronResolution;
				float MipLevel = clamp(log2(NumTexels), 0, ScreenProbeGatherMaxMip);

				for (uint TracingRayIndex = 0; TracingRayIndex < NumSpecularSamples; TracingRayIndex++)
				{
					float4 E = ComputeIndirectLightingSampleE(DispatchThreadId.xy, TracingRayIndex, NumSpecularSamples);
				
					E = BiasBSDFImportantSample(E);

					FBxDFSample BxDFSample = SampleBxDF(SHADING_TERM_SPECULAR, GBufferData, V, E);

					SpecularLighting += InterpolateFromScreenProbes(BxDFSample.L, MipLevel, ScreenProbeAtlasCoord, InterpolationWeights);
				}
			}

			//@todo - replace with SH fit of GGX
			SpecularLighting = lerp(SpecularLighting / (float)NumSpecularSamples, DiffuseLighting / PI, DiffuseLerp);
#endif
			RWRoughSpecularIndirect[DispatchThreadId.xy] = SpecularLighting;
		}
		else
		{
			RWDiffuseIndirect[DispatchThreadId.xy] = 0;
			RWRoughSpecularIndirect[DispatchThreadId.xy] = 0;
		}
	}
}

float HistoryDistanceThreshold;

float ComputeHistoryWeightBasedOnPosition(float2 ScreenPosition, float SceneDepth, float2 OldScreenPosition, float HistoryCameraDepth, float Noise)
{
	float3 WorldPosition = mul(float4(ScreenPosition * SceneDepth, SceneDepth, 1), View.ScreenToWorld).xyz;

	float3 PrevPositionTranslatedWorld = mul(float4(OldScreenPosition * HistoryCameraDepth, HistoryCameraDepth, 1), View.PrevScreenToTranslatedWorld).xyz;
	float3 PrevWorldPosition = PrevPositionTranslatedWorld - View.PrevPreViewTranslation;

	float DistanceToHistoryValue = length(PrevWorldPosition - WorldPosition);
	float RelativeHistoryDistanceThreshold = HistoryDistanceThreshold * lerp(.5f, 1.5f, Noise) / 1000.0f;

	return DistanceToHistoryValue / SceneDepth > RelativeHistoryDistanceThreshold ? 0.0f : 1.0f;
}

Texture2D DiffuseIndirect;
Texture2D RoughSpecularIndirect;
Texture2D DiffuseIndirectHistory;
Texture2D RoughSpecularIndirectHistory;
Texture2D DiffuseIndirectDepthHistory;
Texture2D HistoryConvergence;

float HistoryWeight;
float HistoryConvergenceWeight;

float4 HistoryScreenPositionScaleBias;
float4 HistoryUVMinMax;

Texture2D VelocityTexture;
SamplerState VelocityTextureSampler;

float PrevInvPreExposure;
float InvFractionOfLightingMovingForFullNeighborhoodClamp;

static const int2 kOffsets3x3[8] =
{
	int2(-1, -1),
	int2( 0, -1),
	int2( 1, -1),
	int2(-1,  0),
	int2( 1,  0),
	int2(-1,  1),
	int2( 0,  1),
	int2( 1,  1),
};

float3 ClampHistory(
	Texture2D LightingTexture,
	uint2 ScreenCoord, 
	uint2 MinScreenCoord, 
	uint2 MaxScreenCoord,
	float3 NewLighting,
	float3 HistoryLighting)
{
	float3 NeighborMin = NewLighting;
	float3 NeighborMax = NewLighting;

	UNROLL
	for (uint NeighborId = 0; NeighborId < 8; NeighborId++)
	{
		int2 SampleOffset = kOffsets3x3[NeighborId];

		uint2 NeighborScreenCoord = ScreenCoord + SampleOffset;
		NeighborScreenCoord = clamp(NeighborScreenCoord, MinScreenCoord, MaxScreenCoord);

		float3 Lighting = LightingTexture[NeighborScreenCoord].xyz;
		NeighborMin = min(NeighborMin, Lighting.xyz);
		NeighborMax = max(NeighborMax, Lighting.xyz);
	}

	HistoryLighting = clamp(HistoryLighting, NeighborMin, NeighborMax);
	return HistoryLighting;
}

float3 GetFilteredNeighborhoodLighting(
	Texture2D LightingTexture,
	uint2 ScreenCoord, 
	uint2 MinScreenCoord, 
	uint2 MaxScreenCoord,
	out bool bLightingIsValid)
{
	float3 FilteredLighting = 0;
	float TotalWeight = 0;

	for (uint NeighborId = 0; NeighborId < 8; NeighborId++)
	{
		int2 SampleOffset = kOffsets3x3[NeighborId];

		uint2 NeighborScreenCoord = ScreenCoord + SampleOffset;
		NeighborScreenCoord = clamp(NeighborScreenCoord, MinScreenCoord, MaxScreenCoord);

		float4 Lighting = LightingTexture[NeighborScreenCoord];
		bool bSampleLightingIsValid = Lighting.w > 0.0f;

		if (bSampleLightingIsValid)
		{
			FilteredLighting += Lighting.xyz;
			TotalWeight++;
		}
	}

	bLightingIsValid = TotalWeight > 0;
	return FilteredLighting /= max(TotalWeight, 1.0f);
}

void ScreenProbeTemporalReprojectionDepthRejectionPS(
	float4 SVPosition : SV_POSITION,
	out float4 OutDiffuseIndirect : SV_Target0,
	out float4 OutRoughSpecularIndirect : SV_Target1,
	out float4 OutConvergence : SV_Target2,
	out float OutDepth : SV_Depth)
{
	float2 ScreenUV = SVPosition.xy * View.BufferSizeAndInvSize.zw;
	float2 ScreenPosition = (ScreenUV.xy - View.ScreenPositionScaleBias.wz) / View.ScreenPositionScaleBias.xy;

	float DeviceZ = Texture2DSampleLevel(SceneDepthTexture, GlobalPointClampedSampler, ScreenUV, 0).r;
	float SceneDepth = ConvertFromDeviceZ(DeviceZ);
	float3 HistoryScreenPosition = GetHistoryScreenPosition(ScreenPosition, ScreenUV, DeviceZ);

	float2 HistoryScreenUV = HistoryScreenPosition.xy * HistoryScreenPositionScaleBias.xy + HistoryScreenPositionScaleBias.wz;
	bool bHistoryWasOffscreen = any(HistoryScreenUV > HistoryUVMinMax.zw) || any(HistoryScreenUV < HistoryUVMinMax.xy);
	HistoryScreenUV = clamp(HistoryScreenUV, HistoryUVMinMax.xy, HistoryUVMinMax.zw);

	float4 NewDiffuseLighting = Texture2DSampleLevel(DiffuseIndirect, GlobalPointClampedSampler, ScreenUV, 0);
	float3 HistoryDiffuseIndirect = Texture2DSampleLevel(DiffuseIndirectHistory, GlobalBilinearClampedSampler, HistoryScreenUV, 0).xyz * PrevInvPreExposure * View.PreExposure;
	bool bLightingIsValid = NewDiffuseLighting.w > 0.0f;
	float LightingIsMoving = abs(NewDiffuseLighting.w);

	if (!bLightingIsValid)
	{
		uint2 MinScreenCoord = uint2(0, 0);
		uint2 MaxScreenCoord = (uint2)(View.ViewSizeAndInvSize.xy - 1);
		NewDiffuseLighting.xyz = GetFilteredNeighborhoodLighting(DiffuseIndirect, SVPosition.xy, MinScreenCoord, MaxScreenCoord, bLightingIsValid);
	}

	float EffectiveConvergenceWeight = HistoryConvergenceWeight;
	float NewConvergence = 1;

	float EffectiveHistoryWeight = bLightingIsValid ? HistoryWeight : 1.0f;

	if (bHistoryWasOffscreen)
	{ 
		EffectiveConvergenceWeight = 0;
		NewConvergence = 0;
		EffectiveHistoryWeight = 0;
	}

	float Noise = InterleavedGradientNoise(SVPosition.xy, View.StateFrameIndexMod8);
	float HistoryDepth = ConvertFromDeviceZ(Texture2DSampleLevel(DiffuseIndirectDepthHistory, GlobalBilinearClampedSampler, HistoryScreenUV, 0).x);
	float PositionWeight = ComputeHistoryWeightBasedOnPosition(ScreenPosition, SceneDepth, HistoryScreenPosition.xy, HistoryDepth, Noise);

	EffectiveConvergenceWeight *= PositionWeight;
	NewConvergence *= PositionWeight;

	float ConvergenceHistory = Texture2DSampleLevel(HistoryConvergence, GlobalBilinearClampedSampler, HistoryScreenUV, 0).x;

	float UpdatedConvergence = lerp(NewConvergence, ConvergenceHistory, EffectiveConvergenceWeight);

	float3 NewRoughSpecularLighting = Texture2DSampleLevel(RoughSpecularIndirect, GlobalBilinearClampedSampler, ScreenUV, 0).xyz;
	float3 HistoryRoughSpecularIndirect = Texture2DSampleLevel(RoughSpecularIndirectHistory, GlobalBilinearClampedSampler, HistoryScreenUV, 0).xyz * PrevInvPreExposure * View.PreExposure;

	// Compute the amount of neighborhood clamp history rejection to apply based on what fraction of the probe directions hit fast moving objects
	float NeighborhoodClampAmount = saturate(LightingIsMoving * InvFractionOfLightingMovingForFullNeighborhoodClamp);
	// For performance, skip neighborhood clamp when it would have had a small contribution
	NeighborhoodClampAmount = saturate((NeighborhoodClampAmount - .2f) / .8f);

	if (NeighborhoodClampAmount > 0)
	{
		uint2 MinScreenCoord = uint2(0, 0);
		uint2 MaxScreenCoord = (uint2)(View.ViewSizeAndInvSize.xy - 1);
		float3 ClampedHistoryDiffuseIndirect = ClampHistory(DiffuseIndirect, SVPosition.xy, MinScreenCoord, MaxScreenCoord, NewDiffuseLighting.xyz, HistoryDiffuseIndirect);
		HistoryDiffuseIndirect = lerp(HistoryDiffuseIndirect, ClampedHistoryDiffuseIndirect, NeighborhoodClampAmount);

		float3 ClampedHistoryRoughSpecularIndirect = ClampHistory(RoughSpecularIndirect, SVPosition.xy, MinScreenCoord, MaxScreenCoord, NewRoughSpecularLighting, HistoryRoughSpecularIndirect);
		HistoryRoughSpecularIndirect = lerp(HistoryRoughSpecularIndirect, ClampedHistoryRoughSpecularIndirect, NeighborhoodClampAmount);
	}

	UpdatedConvergence = min(UpdatedConvergence, 1.0f - .5f * NeighborhoodClampAmount);
	EffectiveHistoryWeight *= UpdatedConvergence * lerp(PositionWeight, 1.0f, NeighborhoodClampAmount);

	OutDiffuseIndirect = float4(lerp(NewDiffuseLighting.rgb, HistoryDiffuseIndirect.rgb, EffectiveHistoryWeight), 0);
	OutRoughSpecularIndirect = float4(lerp(NewRoughSpecularLighting.rgb, HistoryRoughSpecularIndirect.rgb, EffectiveHistoryWeight), 0);

	OutDiffuseIndirect.rgb = -min(-OutDiffuseIndirect.rgb, 0.0f);
	OutRoughSpecularIndirect.rgb = -min(-OutRoughSpecularIndirect.rgb, 0.0f);

	OutConvergence = float4(UpdatedConvergence, 0, 0, 0);
	OutDepth = DeviceZ;
}

void CopyDepthPS(
	float4 SVPosition : SV_POSITION,
	out float OutDepth : SV_Depth)
{
	float2 ScreenUV = SVPosition.xy * View.BufferSizeAndInvSize.zw;
	float SceneDepth = CalcSceneDepth(ScreenUV);
	OutDepth = SceneDepth;
}

RWTexture2D<float> RWCompressedDepthBufferOutput;
RWTexture2D<uint> RWCompressedShadingModelOutput;

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void GenerateCompressedGBuffer( 
	uint2 GroupId : SV_GroupID,
	uint2 GroupThreadId : SV_GroupThreadID)
{
	uint2 PixelCoord = GroupId * THREADGROUP_SIZE + GroupThreadId;
	float2 BufferUV = (PixelCoord + View.ViewRectMin.xy + 0.5f) * View.BufferSizeAndInvSize.zw;
	FGBufferData GBuffer = GetGBufferDataFromSceneTextures(BufferUV);

	RWCompressedDepthBufferOutput[PixelCoord] = ConvertToDeviceZ(GBuffer.Depth);
	RWCompressedShadingModelOutput[PixelCoord] = GBuffer.ShadingModelID;
}
