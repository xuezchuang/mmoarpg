// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
	LumenTranslucencyShared.usf
=============================================================================*/

// Temp version GUID to force rebuild of shaders using the FLumenTranslucencyLightingParameters
// uniform buffer, until versioning of uniform buffer structs works properly.
// GUID = 62C0F6D1-F9AB-46A8-9E0C-9E72345B722A

bool IsLumenTranslucencyGIEnabled()
{
	return LumenGIVolumeStruct.TranslucencyGIGridSize.z > 0;
}

float3 ComputeTranslucencyGIVolumeUV(float3 WorldPosition, float4x4 WorldToClip) 
{
	float4 NDCPosition = mul(float4(WorldPosition, 1), WorldToClip);
	NDCPosition.xy /= NDCPosition.w;
	float NormalizedZSlice = log2(NDCPosition.w * LumenGIVolumeStruct.TranslucencyGIGridZParams.x + LumenGIVolumeStruct.TranslucencyGIGridZParams.y) * LumenGIVolumeStruct.TranslucencyGIGridZParams.z / (float)LumenGIVolumeStruct.TranslucencyGIGridSize.z;
	return float3(NDCPosition.xy * float2(.5f, -.5f) + .5f, NormalizedZSlice);
}

FTwoBandSHVectorRGB GetTranslucencyGIVolumeLighting(float3 WorldPosition, float4x4 WorldToClip, bool bTemporalFiltered)
{
	float3 VolumeUV = ComputeTranslucencyGIVolumeUV(WorldPosition, WorldToClip);

	float3 AmbientLightingVector;
	float3 DirectionalLightingVector;
	
	if (bTemporalFiltered)
	{
		AmbientLightingVector = Texture3DSampleLevel(LumenGIVolumeStruct.TranslucencyGIVolumeHistory0, LumenGIVolumeStruct.TranslucencyGIVolumeSampler, VolumeUV, 0).xyz;
		DirectionalLightingVector = Texture3DSampleLevel(LumenGIVolumeStruct.TranslucencyGIVolumeHistory1, LumenGIVolumeStruct.TranslucencyGIVolumeSampler, VolumeUV, 0).xyz;
	}
	else
	{
		AmbientLightingVector = Texture3DSampleLevel(LumenGIVolumeStruct.TranslucencyGIVolume0, LumenGIVolumeStruct.TranslucencyGIVolumeSampler, VolumeUV, 0).xyz;
		DirectionalLightingVector = Texture3DSampleLevel(LumenGIVolumeStruct.TranslucencyGIVolume1, LumenGIVolumeStruct.TranslucencyGIVolumeSampler, VolumeUV, 0).xyz;
	}

	// Reconstruct the SH coefficients based on what was encoded
	FTwoBandSHVectorRGB TranslucentLighting;
	TranslucentLighting.R.V.x = AmbientLightingVector.r;
	TranslucentLighting.G.V.x = AmbientLightingVector.g;
	TranslucentLighting.B.V.x = AmbientLightingVector.b;
	float3 NormalizedAmbientColor = AmbientLightingVector.rgb / ( Luminance( AmbientLightingVector.rgb ) + 0.00001f );

	// Scale the monochrome directional coefficients with the normalized ambient color as an approximation to the uncompressed values
	TranslucentLighting.R.V.yzw = DirectionalLightingVector.rgb * NormalizedAmbientColor.r;
	TranslucentLighting.G.V.yzw = DirectionalLightingVector.rgb * NormalizedAmbientColor.g;
	TranslucentLighting.B.V.yzw = DirectionalLightingVector.rgb * NormalizedAmbientColor.b;
	return TranslucentLighting;
}
