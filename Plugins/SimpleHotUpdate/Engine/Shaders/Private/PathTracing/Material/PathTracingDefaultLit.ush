// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================================
	PathTracingDefaultLit.usf: Path tracing BRDF model for default lit material
===============================================================================================*/

#pragma once

#include "PathTracingFresnel.ush"

// be conservative since the GPU may be aggressive with floating point optimizations
#define GGX_MIN_ROUGHNESS 0.01

float CalcLobeSelectionPdf(float3 V, FMaterialClosestHitPayload Payload)
{
	// TODO: This could be improved if we had a directional albedo tabulation, but this formulation will at least prevent
	// under-sampling when one lobe is black (like with metals)

	float3 Diff = GetDiffuseColor(Payload);
	float3 Spec = GetSpecularColor(Payload);

	float D = Diff.x + Diff.y + Diff.z;
	float S = Spec.x + Spec.y + Spec.z;
	return D / (D + S + 1e-6);
}

void DefaultLit_EvalMaterial(
	float3 IncomingDirection,
	float3 OutgoingDirection,
	FMaterialClosestHitPayload Payload,
	out float3 OutWeight,
	out float OutPdf
)
{
	OutWeight = 0;
	OutPdf = 0;

	float3 V_World = -IncomingDirection;
	float3 L_World = OutgoingDirection;
	float3 N_World = GetWorldNormal(Payload);

	float Roughness = max(GetRoughness(Payload), GGX_MIN_ROUGHNESS);
	float2 Alpha;
	float3x3 Basis;
	if (Payload.HasAnisotropy())
	{
		// Material is anisotropic, our shading frame should use the tangent vector
		GetAnisotropicRoughness(Roughness * Roughness, Payload.Anisotropy, Alpha.x, Alpha.y);
		float3 X = Payload.WorldTangent;
		float3 Y = normalize(cross(N_World, X));
		Basis = float3x3(cross(Y, N_World), Y, N_World);
	}
	else
	{
		// No anisotropy, just pick an arbitrary basis
		Alpha = Roughness * Roughness;
		Basis = GetTangentBasis(N_World);
	}

	// move vectors into right shading frame
	float3 V = mul(Basis, V_World);
	float3 L = mul(Basis, L_World);
	float3 H = normalize(V + L);

	float NoL = saturate(L.z);
	float NoV = saturate(V.z);
	float NoH = saturate(H.z);
	float VoH = saturate(dot(V, H));

	// Probability of picking diffuse lobe vs. specular lobe
	float LobeSelectionPdf = CalcLobeSelectionPdf(V_World, Payload);

	// Diffuse Lobe
	AddLobeWithMIS(OutWeight, OutPdf, GetDiffuseColor(Payload), NoL / PI, LobeSelectionPdf);

	// Specular lobe
	if (NoL > 0 && NoV > 0)
	{
		// Assume NoH > 0
		// FIXME: this can be further simplified
		const float CosThetaM4 = Pow2(NoH);
		const float TanThetaM2 = (Pow2(H.x / Alpha.x) + Pow2(H.y / Alpha.y)) / Pow2(NoH);
		const float D = 1 / (PI * Pow2(1 + TanThetaM2) * Alpha.x * Alpha.y * CosThetaM4);
		const float Lambda_o = 0.5 * (-1.0 + sqrt(1.0 + (Pow2(L.x * Alpha.x) + Pow2(L.y * Alpha.y)) / Pow2(L.z)));
		const float Lambda_i = 0.5 * (-1.0 + sqrt(1.0 + (Pow2(V.x * Alpha.x) + Pow2(V.y * Alpha.y)) / Pow2(V.z)));
		const float G2 = 1 / (Lambda_i + Lambda_o + 1);
		const float G1 = 1 / (Lambda_i + 1);

		// match behavior in SpecularGGX
		const float3 F = F_Schlick(GetSpecularColor(Payload), VoH);

		const float3 SpecWeight = F * (G2 / G1);
		const float SpecPdf = (G1 * D * 0.25f) / NoV;

		AddLobeWithMIS(OutWeight, OutPdf, SpecWeight, SpecPdf, 1.0 - LobeSelectionPdf);
	}
}

void DefaultLit_SampleMaterial(
	float3 RayDirection,
	FMaterialClosestHitPayload Payload,
	float4 RandSample,
	out float3 OutDirection,
	out float3 OutWeight,
	out float OutPdf
)
{
	float3 N = GetWorldNormal(Payload);
	float3 V = -RayDirection;
	
	float LobeSelectionPdf = CalcLobeSelectionPdf(V, Payload);

	OutDirection = 0;
	OutWeight = 0;
	OutPdf = 0;
	
	// Choose lobe based on roughness
	if (RandSample.x < LobeSelectionPdf)
	{
		RandSample.x /= LobeSelectionPdf;

		// Lambert
		float4 Result = CosineSampleHemisphere(RandSample.xy);
		OutDirection = TangentToWorld(Result.xyz, N);
	}
	else
	{
		RandSample.x -= LobeSelectionPdf;
		RandSample.x /= (1.0 - LobeSelectionPdf);

		float Roughness = max(GetRoughness(Payload), GGX_MIN_ROUGHNESS);
		float2 Alpha;
		float3x3 Basis;
		if (Payload.HasAnisotropy())
		{
			// Material is anisotropic, our shading frame should use the tangent vector
			GetAnisotropicRoughness(Roughness * Roughness, Payload.Anisotropy, Alpha.x, Alpha.y);
			float3 X = Payload.WorldTangent;
			float3 Y = normalize(cross(N, X));
			Basis = float3x3(cross(Y, N), Y, N);
		}
		else
		{
			// No anisotropy, just pick an arbitrary basis
			Alpha = Roughness * Roughness;
			Basis = GetTangentBasis(N);
		}

		V = mul(Basis, V);

		// #dxr_todo: Switch to UniformSampleDiskConcentric after fixing 0/0 bug
		float3 H = ImportanceSampleVisibleGGX_aniso(UniformSampleDisk(RandSample.xy), Alpha, V).xyz;

		float3 L = reflect(-V, H);
		if (L.z <= 0) {
			// invalid output direction, exit early
			return;
		}
		// transform to world space
		OutDirection = normalize(mul(L, Basis));
	}

	// Call eval to get the proper weight/pdf for the sampled direction
	// TODO: might be cheaper to inline the eval here and take advantage of already computed terms?
	// It is possible that the compiler is doing some of this for us already though ...
	DefaultLit_EvalMaterial(RayDirection, OutDirection, Payload, OutWeight, OutPdf);
}
