// Copyright Epic Games, Inc. All Rights Reserved.

/*=============================================================================
ProjectionCommon.ush:
=============================================================================*/
#pragma once

#include "../Common.ush"
#include "../ScreenSpaceDenoise/SSDDefinitions.ush"		// For LIGHT_TYPE's
#include "PageAccessCommon.ush"
#include "ProjectionStructs.ush"

#define VIRTUAL_SHADOW_MAP_MIN_OCCLUDER_DISTANCE 1e-6f

float CalcClipmapLevelFloat(FVirtualShadowMapProjectionShaderData BaseProjectionData, float3 WorldPosition)
{
	float DistanceToClipmapOrigin = length(WorldPosition - BaseProjectionData.ClipmapWorldOrigin);
	float Log2Distance = log2(DistanceToClipmapOrigin);
	float AbsoluteLevel = Log2Distance + BaseProjectionData.ClipmapResolutionLodBias;
	return AbsoluteLevel;
}

int CalcClipmapLevel(FVirtualShadowMapProjectionShaderData BaseProjectionData, float3 WorldPosition)
{
	return int(floor(CalcClipmapLevelFloat(BaseProjectionData, WorldPosition)));
}

struct FVirtualShadowMapSample
{
	float Depth;
	uint MipLevel;
	int VirtualShadowMapId;		// May be offset from input for clipmaps
	bool bValid;
	uint2 VirtualTexelAddress;
	float2 VirtualTexelAddressFloat;
	uint2 PhysicalTexelAddress;
};

FVirtualShadowMapSample InitVirtualShadowMapSample()
{
	FVirtualShadowMapSample Result;
	Result.Depth = 0.0f;
	Result.MipLevel = 0;
	Result.VirtualShadowMapId = -1; 
	Result.bValid = false;
	Result.VirtualTexelAddress = Result.PhysicalTexelAddress = uint2(0U, 0U);
	Result.VirtualTexelAddressFloat = float2(0.0f, 0.0f);
	return Result;
}

#ifndef TWO_PHYSICAL_TEXTURES
#define TWO_PHYSICAL_TEXTURES 1
#endif

float SampleVirtualShadowMapPhysicalDepth(uint2 PhysicalTexelAddress)
{
#if ENABLE_NON_NANITE_VSM && TWO_PHYSICAL_TEXTURES
	return max(
		asfloat(VirtualShadowMap.PhysicalPagePool.Load(int3(PhysicalTexelAddress, 0))),
		VirtualShadowMap.PhysicalPagePoolHw.Load(int3(PhysicalTexelAddress, 0))
	);
#else
	return asfloat(VirtualShadowMap.PhysicalPagePool.Load(int3(PhysicalTexelAddress, 0)));
#endif
}

FVirtualShadowMapSample SampleVirtualShadowMapLevel(int VirtualShadowMapId, float2 ShadowMapUV, uint MipLevel)
{
	FVirtualShadowMapSample Result = InitVirtualShadowMapSample();

	Result.VirtualTexelAddressFloat = ShadowMapUV * float(CalcLevelDimsTexels(MipLevel));
	Result.VirtualTexelAddress = uint2(Result.VirtualTexelAddressFloat);

	bool PagePresent = VirtualToPhysicalTexel(VirtualShadowMapId, MipLevel, Result.VirtualTexelAddress, Result.PhysicalTexelAddress);
	if (PagePresent)
	{
		Result.Depth = SampleVirtualShadowMapPhysicalDepth(Result.PhysicalTexelAddress);
		Result.MipLevel = MipLevel;
		Result.VirtualShadowMapId = VirtualShadowMapId;
		Result.bValid = true;
	}
	
	return Result;
}

FVirtualShadowMapSample SampleVirtualShadowMap(int VirtualShadowMapId, float2 ShadowMapUV)
{
	FShadowPageTranslationResult Page = ShadowVirtualToPhysicalUV(VirtualShadowMapId, ShadowMapUV);
	if (Page.bValid)
	{
		FVirtualShadowMapSample Result;
		Result.bValid = true;
		Result.MipLevel = Page.LODOffset;
		Result.VirtualShadowMapId = VirtualShadowMapId;
		Result.VirtualTexelAddress = Page.VirtualTexelAddress;
		Result.VirtualTexelAddressFloat = Page.VirtualTexelAddressFloat;
		Result.PhysicalTexelAddress = Page.PhysicalTexelAddress;
		Result.Depth = SampleVirtualShadowMapPhysicalDepth(Result.PhysicalTexelAddress);
		return Result;
	}

	return InitVirtualShadowMapSample();
}


// Data to convert UV's and depths from one clipmap level basis to another
struct FVirtualShadowMapClipmapRelativeTransform
{
	float Scale;
	float3 Bias;
};

// Resulting transform takes UV's/depths from clipmap level ClipmapId to ClipmapId + LevelOffset 
// ClipmapId + LevelOffset should be a valid level in the same clipmap
FVirtualShadowMapClipmapRelativeTransform CalcClipmapRelativeTransform(int ClipmapId, int LevelOffset)
{
	const FVirtualShadowMapProjectionShaderData ProjectionDataA = GetVirtualShadowMapProjectionData(ClipmapId);
	const FVirtualShadowMapProjectionShaderData ProjectionDataB = GetVirtualShadowMapProjectionData(ClipmapId + LevelOffset);

	float2 OffsetA = float2(ProjectionDataA.ClipmapCornerOffset);
	float2 OffsetB = float2(ProjectionDataB.ClipmapCornerOffset);

	FVirtualShadowMapClipmapRelativeTransform Result;
	Result.Scale = exp2(-float(LevelOffset));
	Result.Bias.xy = 0.25f * (OffsetB - Result.Scale * OffsetA);
	// NOTE: Currently no snapping in Z
	Result.Bias.z = 0.5f - Result.Scale * 0.5f;
	return Result;
}

// Will sample from the given clipmap level Id, onwards to coarser levels if no valid data is present
// ShadowMapUVs are in terms of the given clipmap level/virtual shadow map
FVirtualShadowMapSample SampleVirtualShadowMapClipmap(int VirtualShadowMapId, float2 ShadowMapUV)
{
	FVirtualShadowMapSample Result = InitVirtualShadowMapSample();

#define DEBUG_VSM_CLIPMAP_LEVEL_SEARCH 0
#if !DEBUG_VSM_CLIPMAP_LEVEL_SEARCH
	FShadowPageTranslationResult Page = ShadowVirtualToPhysicalUV(VirtualShadowMapId, ShadowMapUV);
	if (Page.bValid)
	{
		FVirtualShadowMapClipmapRelativeTransform Transform = CalcClipmapRelativeTransform(VirtualShadowMapId, Page.LODOffset);
		float2 ClipmapUV = ShadowMapUV * Transform.Scale + Transform.Bias.xy;
		Result = SampleVirtualShadowMapLevel(VirtualShadowMapId + Page.LODOffset, ClipmapUV, 0);
		if (Result.bValid)
		{
			// Convert depth into back into the original reference clipmap level range
			Result.Depth = (Result.Depth - Transform.Bias.z) / Transform.Scale;
		}
	}
#else // DEBUG_VSM_CLIPMAP_LEVEL_SEARCH
	FVirtualShadowMapProjectionShaderData BaseProjectionData = GetVirtualShadowMapProjectionData(VirtualShadowMapId);
	const int MaxOffset = BaseProjectionData.ClipmapLevelCount - BaseProjectionData.ClipmapIndex;
	for (int Offset = 0; Offset < MaxOffset; ++Offset)
	{
		FVirtualShadowMapClipmapRelativeTransform Transform = CalcClipmapRelativeTransform(VirtualShadowMapId, Offset);		
		float2 ClipmapUV = ShadowMapUV * Transform.Scale + Transform.Bias.xy;
		Result = SampleVirtualShadowMapLevel(VirtualShadowMapId + Offset, ClipmapUV, 0);
		if (Result.bValid)
		{
			// Convert depth into back into the original reference clipmap level range
			Result.Depth = (Result.Depth - Transform.Bias.z) / Transform.Scale;
			break;
		}
	}
#endif // DEBUG_VSM_CLIPMAP_LEVEL_SEARCH

	return Result;
}

float ComputeVirtualShadowMapOptimalSlopeBias(
	// Used to compare to the sampled SmSample.VirtualShadowMapId to adjust depth scale for clipmaps
	int RequestedVirtualShadowMapId,
	FVirtualShadowMapSample SmSample,
	float3 WorldPosition,
	float3 EstimatedGeoWorldNormal)
{
	FVirtualShadowMapProjectionShaderData ProjectionData = GetVirtualShadowMapProjectionData(SmSample.VirtualShadowMapId);

	// Transform geometry world-space plane eq to shadow 'UV' texture space [0-1] ranges
	float4 NormalPlaneTranslatedWorld = float4(EstimatedGeoWorldNormal, -dot(EstimatedGeoWorldNormal, WorldPosition + ProjectionData.ShadowPreViewTranslation));
	float4 NormalPlaneUV = mul(NormalPlaneTranslatedWorld, ProjectionData.TranslatedWorldToShadowUVNormalMatrix);

	float2 DepthSlopeUV = -NormalPlaneUV.xy / NormalPlaneUV.z;
	float MipLevelDim = float(CalcLevelDimsTexels(SmSample.MipLevel));
	float2 TexelCenter = float2(SmSample.VirtualTexelAddress) + 0.5f;
	float2 TexelCenterOffset = TexelCenter - SmSample.VirtualTexelAddressFloat;
	float2 TexelCenterOffsetUV = TexelCenterOffset / MipLevelDim;
	// 2x factor due to lack of precision (probably)
	float OptimalSlopeBias = 2.0f * max(0.0f, dot(DepthSlopeUV, TexelCenterOffsetUV));
	
	// Clamp to avoid excessive degenerate slope biases causing flickering lit pixels
	OptimalSlopeBias = min(OptimalSlopeBias, abs(100.0f * ProjectionData.ShadowViewToClipMatrix._33));

	// Adjust depth scale if we sampled a different clipmap level
	// NOTE: Sampled clipmap should always be >= the requested one (coarser)
	// Do this after clamping to be consistent in world space
	OptimalSlopeBias *= float(1u << (SmSample.VirtualShadowMapId - RequestedVirtualShadowMapId));

	return OptimalSlopeBias;
}

// Used for orthographic projections (i.e. directional lights)
// Receiver depth is post-projection-divide.
float ComputeOccluderDistanceOrtho(float4x4 ShadowViewToClip, float OccluderDepth, float ReceiverDepth)
{
	float OccluderViewZ = (OccluderDepth - ShadowViewToClip._43) / ShadowViewToClip._33;
	float ReceiverViewZ = (ReceiverDepth - ShadowViewToClip._43) / ShadowViewToClip._33;

	// No perspective projection, so simple difference gets us the distance
	float Result = ReceiverViewZ - OccluderViewZ;
	return max(VIRTUAL_SHADOW_MAP_MIN_OCCLUDER_DISTANCE, Result);
}

// Used for perspective projections (i.e. spot lights)
// Receiver depth is post-projection-divide.
float ComputeOccluderDistancePerspective(float4x4 ShadowViewToClip, float OccluderDepth, float ReceiverDepth, float ReceiverDistance)
{
	float OccluderViewZ = ShadowViewToClip._43 / (OccluderDepth - ShadowViewToClip._33);
	float ReceiverViewZ = ShadowViewToClip._43 / (ReceiverDepth - ShadowViewToClip._33);

	// Similar triangles to compute euclidean distance in view/world space
	float OccluderDistance = (ReceiverDistance / ReceiverViewZ) * OccluderViewZ;
	float Result = ReceiverDistance - OccluderDistance;	
	return max(VIRTUAL_SHADOW_MAP_MIN_OCCLUDER_DISTANCE, Result);
}

uint VirtualShadowMapGetCubeFace( float3 Dir )
{
	// TODO use v_cubeid_f32( Dir )
	if( abs(Dir.x) >= abs(Dir.y) && abs(Dir.x) >= abs(Dir.z) )
		return Dir.x > 0 ? 0 : 1;
	else if( abs(Dir.y) > abs(Dir.z) )
		return Dir.y > 0 ? 2 : 3;
	else
		return Dir.z > 0 ? 4 : 5;
}

struct FVirtualShadowMapSampleResult
{
	bool bValid;
	float ShadowFactor;	// 0 = fully occluded, 1 = no occlusion
	bool bOccluded;
	float OccluderDistance;

	// Offset from expected clipmap level that this sample represents. If >0 data is courser than calculated LOD.
	// Only valid for directional lights.
	int ClipmapLevelOffset;

	// Debug data	
	int ClipmapIndexOrMipLevel;
};

/**
* VirtualShadowMapId is the ID of the virtual shadow map to sample
* WorldPosition is the sample position in world space to project into the shadow map
* RayStartDistance is an optional offset to move the lookup along the shadow ray towards the light
*   - Should be zero or positive
*   - This offset is useful in that it does *not* affect the selection of clipmap level, unlike offsetting the WorldPosition itself
*   - OccluderDistance will still be relative to the original sample position
* * EstimatedGeoWorldNormal is ideally the geometric (flat) normal of the sample point in world space
*   - If bUseOptimalBias is true, this is used to compute a receiver-plane-based bias for the sample point
*   - The shading normal can be used if the geometric normal is not available, but divergence from the geometric normal can cause biasing issues.
*/
FVirtualShadowMapSampleResult SampleVirtualShadowMapInner(int VirtualShadowMapId, float3 WorldPosition, float RayStartDistance, bool bUseOptimalBias, float3 EstimatedGeoWorldNormal)
{
	RayStartDistance = max(RayStartDistance, 0.0f);

	FVirtualShadowMapProjectionShaderData BaseProjectionData = GetVirtualShadowMapProjectionData(VirtualShadowMapId);

	if (BaseProjectionData.LightType == LIGHT_TYPE_DIRECTIONAL)
	{
		const int FirstClipmapLevel = BaseProjectionData.ClipmapLevel;
		const int ClipmapLevel = CalcClipmapLevel(BaseProjectionData, WorldPosition);
		int ClipmapIndex = max(0, ClipmapLevel - FirstClipmapLevel);

		// Check if sample is within the clipmap range (from camera)
		if (ClipmapIndex < BaseProjectionData.ClipmapLevelCount)
		{
			int ClipmapLevelVirtualShadowMapId = VirtualShadowMapId + ClipmapIndex;
			FVirtualShadowMapProjectionShaderData ProjectionData = GetVirtualShadowMapProjectionData(ClipmapLevelVirtualShadowMapId);

			// No perspective divided needed for ortho projection
			float4 ShadowUVz = mul(float4(WorldPosition + ProjectionData.ShadowPreViewTranslation, 1.0f), ProjectionData.TranslatedWorldToShadowUVMatrix);
			
			FVirtualShadowMapSample SmSample;
			//SmSample = SampleVirtualShadowMapLevel(ClipmapLevelVirtualShadowMapId, ShadowUVz.xy, 0);
			SmSample = SampleVirtualShadowMapClipmap(ClipmapLevelVirtualShadowMapId, ShadowUVz.xy);
			
			if (SmSample.bValid)
			{
				int SampledClipmapIndex = SmSample.VirtualShadowMapId - VirtualShadowMapId;

				FVirtualShadowMapSampleResult Result;
				Result.bValid = true;
				Result.bOccluded = false;
				Result.OccluderDistance = -1.0f;
				Result.ClipmapLevelOffset = SmSample.VirtualShadowMapId - ClipmapLevelVirtualShadowMapId;
				Result.ClipmapIndexOrMipLevel = SampledClipmapIndex;

				float OptimalSlopeBias = bUseOptimalBias 
					? ComputeVirtualShadowMapOptimalSlopeBias(ClipmapLevelVirtualShadowMapId, SmSample, WorldPosition, EstimatedGeoWorldNormal)
					: 0.0f;
				
				float RayStartBias = -RayStartDistance * ProjectionData.ShadowViewToClipMatrix._33;
				float BiasedDepth = SmSample.Depth - OptimalSlopeBias - RayStartBias;

				if (BiasedDepth > ShadowUVz.z)
				{
					Result.bOccluded = true;
					Result.OccluderDistance = ComputeOccluderDistanceOrtho(
						ProjectionData.ShadowViewToClipMatrix,
						SmSample.Depth,
						ShadowUVz.z);
				}

				Result.ShadowFactor = Result.bOccluded ? 0.0f : 1.0f;
				return Result;
			}
		}
	}
	else
	{
		float3 TranslatedWorldPosition = WorldPosition + BaseProjectionData.ShadowPreViewTranslation;

		if( BaseProjectionData.LightType != LIGHT_TYPE_SPOT )
		{
			VirtualShadowMapId += VirtualShadowMapGetCubeFace( TranslatedWorldPosition );
			BaseProjectionData = GetVirtualShadowMapProjectionData( VirtualShadowMapId );
		}

		// TODO cubemap math directly instead of vector fetching matrix
		float4 ShadowUVz = mul(float4(TranslatedWorldPosition, 1.0f), BaseProjectionData.TranslatedWorldToShadowUVMatrix);
		ShadowUVz.xyz /= ShadowUVz.w;

		FVirtualShadowMapSample SmSample = SampleVirtualShadowMap(VirtualShadowMapId, ShadowUVz.xy);
		if (SmSample.bValid)
		{
			FVirtualShadowMapSampleResult Result;
			Result.bValid = true;
			Result.bOccluded = false;
			Result.OccluderDistance = -1.0f;
			Result.ClipmapLevelOffset = 0;
			Result.ClipmapIndexOrMipLevel = SmSample.MipLevel;

			float OptimalSlopeBias = bUseOptimalBias 
				? ComputeVirtualShadowMapOptimalSlopeBias(VirtualShadowMapId, SmSample, WorldPosition, EstimatedGeoWorldNormal)
				: 0.0f;

			float RayStartBias = -RayStartDistance * BaseProjectionData.ShadowViewToClipMatrix._33 / ShadowUVz.w;
			float BiasedDepth = SmSample.Depth - OptimalSlopeBias - RayStartBias;

			if (BiasedDepth > ShadowUVz.z)
			{
				Result.bOccluded = true;
				// Shadow view matrix is rotation
				float ReceiverDistance = length(TranslatedWorldPosition);
				Result.OccluderDistance = RayStartDistance + ComputeOccluderDistancePerspective(
					BaseProjectionData.ShadowViewToClipMatrix,
					SmSample.Depth,
					ShadowUVz.z,
					ReceiverDistance);
			}

			Result.ShadowFactor = Result.bOccluded ? 0.0f : 1.0f;
			return Result;
		}
	}

	// Invalid
	FVirtualShadowMapSampleResult Result = (FVirtualShadowMapSampleResult)0;
	Result.bValid = false;
	Result.bOccluded = false;
	Result.ShadowFactor = 1.0f;
	Result.OccluderDistance = -1.0f;
	Result.ClipmapLevelOffset = 0;
	Result.ClipmapIndexOrMipLevel = -1;
	return Result;
}

FVirtualShadowMapSampleResult SampleVirtualShadowMap(int VirtualShadowMapId, float3 WorldPosition, float RayStartDistance = 0.0f)
{
	return SampleVirtualShadowMapInner(VirtualShadowMapId, WorldPosition, RayStartDistance, false, float3(0, 0, 0));
}

FVirtualShadowMapSampleResult SampleVirtualShadowMap(int VirtualShadowMapId, float3 WorldPosition, float RayStartDistance, float3 EstimatedGeoWorldNormal)
{
	return SampleVirtualShadowMapInner(VirtualShadowMapId, WorldPosition, RayStartDistance, true, EstimatedGeoWorldNormal);
}
